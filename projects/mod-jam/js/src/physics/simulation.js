/**
 * Simulation
 *
 * A class used to manage the physics bodies simulation.
 * It is meant to be a pause-able simulation without affecting the framerate.
 * This is helpful for debugging purposes, as it allows to have a deterministic continuation
 * of the physics simulation, no matter if the frame rate varies over time.
 * It also allows to pause the simulation to go step by step through the simulation to debug/collect
 * traces.
 *
 * This code was generated by ChatGPT 5.0 Thinking as a set of global const and window-attached
 * functions, and I then converted it to a class to encapsulate everything in a single unit of work.
 * Hence the logic is primarily GenAI generated.
 */
export default class Simulation {
  constructor() {
    // former globals
    this.DEBUG_MODE = false; // when true, ignore deltaTime; run by frame count
    this.SIM_HZ = 60; // fixed "displayed framerate" for debug stepping
    this.SIM_DT = 1 / this.SIM_HZ; // debug dt per physics step

    this.paused = false; // paused flag
    this.runContinuous = true; // do exactly 1 physics step per draw()
    this.stepQueued = 0; // queued single steps
    this.frame = 0; // physics steps performed
    this.time = 0; // simulation time in seconds
  }

  // --- controls (formerly on window.*) ---
  pause() {
    this.paused = true;
    this.runContinuous = false;
  }

  run() {
    this.paused = false;
    this.runContinuous = true;
  }

  toggle() {
    if (this.paused) this.run();
    else this.pause();
  }

  step(n = 1) {
    this.paused = true;
    this.runContinuous = false;
    this.stepQueued += Math.max(1, n | 0);
  }

  setHz(hz) {
    this.SIM_HZ = Math.max(1, hz | 0);
    this.SIM_DT = 1 / this.SIM_HZ;
    console.log(`[sim] debug Hz=${this.SIM_HZ}, dt=${this.SIM_DT.toFixed(5)}s`);
  }

  status() {
    return {
      SIM_DEBUG_MODE: this.DEBUG_MODE,
      SIM_HZ: this.SIM_HZ,
      SIM_DT: this.SIM_DT,
      simPaused: this.paused,
      simRunContinuous: this.runContinuous,
      simStepQueued: this.stepQueued,
      simFrame: this.frame,
      simTime_s: this.time,
    };
  }

  // (optional) helpers you might call from your engine loop:
  // mark one physics step as completed
  onPhysicsStepDone() {
    this.frame += 1;
    this.time = this.frame * this.SIM_DT;
  }
  // consume one queued step (returns true if one was consumed)
  takeQueuedStep() {
    if (this.stepQueued > 0) {
      this.stepQueued -= 1;
      return true;
    }
    return false;
  }
}
