
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="UTF-8">
          <title>ChatGPT Conversation Log</title>
          <style>
            :root {
              --primary-color: #FFF;
              --user-color: #ff3333;
              --font-size: 16px;
            }
          
            body {
              font-family: ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica,Apple Color Emoji,Arial,sans-serif,Segoe UI Emoji,Segoe UI Symbol;
              font-size: var(--font-size);
              background-color: #212121;
              color: var(--primary-color);
              padding: 20px;
              margin: 0 auto;
              line-height: 1.5;
            }
            .header {
              text-align: center;
              margin-bottom: 30px;
              border-bottom: 2px dashed var(--primary-color);
              padding-bottom: 15px;
              max-width: 1200px;
              margin-left: auto;
              margin-right: auto;
            }
            .title {
              font-size: 24px;
              font-weight: bold;
              margin: 0;
              text-transform: uppercase;
              letter-spacing: 2px;
            }
            .timestamp {
              color: #00cc00;
              font-size: 14px;
              margin-top: 10px;
            }
            .conversation {
              max-width: 1200px;
              margin: 0 auto;
              padding: 20px;
            }
            .message {
              margin-bottom: 20px;
              padding: 10px 20px;
              border-radius: 18px;
              width: fit-content;
              max-width: 80%;
              clear: both;
              overflow: hidden;
            }
            .user-message {
              float: right;
              background-color: #303030;
            }
            .assistant-message {
              float: left;
            }
            .role {
              font-weight: bold;
              margin-bottom: 5px;
              text-transform: uppercase;
            }
            .user-message .role {
              color: #ff3333;
              text-align: right;
            }
            .assistant-message .role {
              color: var(--primary-color);
            }
            .content {
              user-select: text;
              word-wrap: break-word;
            }
            table {
              border: 1px solid var(--primary-color);
              border-collapse: collapse;
              width: 100%;
              margin: 1em 0;
              table-layout: fixed;
            }
            th, td {
                border: 1px solid var(--primary-color);
                text-align: center;
                height: 30px;
                vertical-align: middle;
                padding: 0 10px;
            }
            .content h1 { font-size: 2em; margin: 0.67em 0; }
            .content h2 { font-size: 1.5em; margin: 0.75em 0; }
            .content h3 { font-size: 1.17em; margin: 0.83em 0; }
            .content h4 { font-size: 1em; margin: 1.12em 0; }
            .content h5 { font-size: 0.83em; margin: 1.5em 0; }
            .content h6 { font-size: 0.75em; margin: 1.67em 0; }
            .code-block {
              background-color: #2a2a2a !important;
              color: #fff !important;
              padding: 15px !important;
              margin: 10px 0 !important;
              border-radius: 5px !important;
              border: 1px solid var(--primary-color) !important;
              font-family: "Courier New", monospace !important;
              overflow-x: auto !important;
              width: auto !important;
              max-width: 100% !important;
              box-sizing: border-box !important;
            }
            li{
              margin:15px 0;
            }
            .inline-code{
              background: var(--primary-color);
              color:#000;
              padding:2px 5px;
            }
            /* Basic highlight.js theme */
            .hljs {
              background: transparent;
              color: #fff;
            }
            .hljs-keyword { color: #ff79c6; }
            .hljs-string { color: #f1fa8c; }
            .hljs-number { color: #bd93f9; }
            .hljs-function { color: #50fa7b; }
            .hljs-comment { color: #6272a4; }
            .hljs-title { color: #50fa7b; }
            .hljs-params { color: #f8f8f2; }
            .hljs-built_in { color: #8be9fd; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1 class="title">== ChatGPT Log ==</h1>
            <div class="timestamp">[2025-09-29, 10:15:31 p.m.]</div>
          </div>
          <div class="conversation">
    
        <div class="message user-message">
          <div class="content">The above log is the entire content of a previous conversation which was started in private/temporary mode. Can you please read the content and summarize what you have understood and what are the next steps at that point?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p class="first:mt-0 my-1.5 h-8 flex items-center ltr:me-auto rtl:ms-auto empty:hidden text-token-text-secondary"></p><p>Here’s a clear summary of what happened in that private conversation log and where things were left off:</p>

<h2>What was discussed</h2>
<ul>
<li>
<p><strong>User goal:</strong>
They wanted to create a custom React component <code>&lt;P5&gt;</code> to integrate <strong>p5.js</strong> in a declarative, React-friendly way. Instead of passing a full sketch function (like with <code>@p5-wrapper/react</code>), they wanted a structure like:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes">&lt;<span class="hljs-variable constant_">P5</span> width={<span class="hljs-number">600</span>} height={<span class="hljs-number">400</span>} renderer=<span class="hljs-string">"WEBGL"</span>&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{...}</span> <span class="hljs-attr">params</span>=<span class="hljs-string">{{...}}</span> /&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{...}</span> <span class="hljs-attr">params</span>=<span class="hljs-string">{{...}}</span> /&gt;</span></span>
&lt;/<span class="hljs-variable constant_">P5</span>&gt;
</code></pre>
<p>This design allows:</p>
<ul>
<li>
<p>Automatic canvas setup &amp; teardown when core props change.</p>
</li>
<li>
<p>Hot-swappable <code>&lt;P5.Draw&gt;</code> functions (without tearing down the canvas).</p>
</li>
<li>
<p>Optionally exposing a <code>useP5()</code> hook to access the current p5 instance, canvas, and state.</p>
</li>
</ul>
</li>
<li>
<p><strong>Assistant’s response (step 1):</strong></p>
<ul>
<li>
<p>Reviewed the design’s <strong>pros</strong> (declarative lifecycle, hot-swappable draw, clean parameter separation, React-like API) and <strong>cons</strong> (children-as-API complexity, possible flicker when re-creating canvas, quirks with p5 instance recreation, SSR considerations).</p>
</li>
<li>
<p>Proposed a slightly refined API using <code>params={{...}}</code> objects instead of positional args, for better typing and memoization.</p>
</li>
<li>
<p>Supplied a <strong>full implementation in TypeScript</strong>, with:</p>
<ul>
<li>
<p><code>&lt;P5&gt;</code>, <code>&lt;P5.Setup&gt;</code>, <code>&lt;P5.Draw&gt;</code> components.</p>
</li>
<li>
<p>A <code>useP5()</code> hook.</p>
</li>
<li>
<p>Lifecycle logic to handle canvas creation, teardown, and hot-swapping.</p>
</li>
</ul>
</li>
<li>
<p>Provided multiple usage examples (simple WEBGL demo, dynamic props, using the hook).</p>
</li>
<li>
<p>Included notes on React 18 StrictMode, resizing behavior, and performance best practices.</p>
</li>
</ul>
</li>
<li>
<p><strong>User’s follow-up:</strong>
They asked for the code in <strong>plain JavaScript (not TypeScript).</strong></p>
</li>
<li>
<p><strong>Assistant’s response (step 2):</strong>
Delivered a <strong>JavaScript rewrite</strong> (<code>P5.jsx</code>), functionally identical but without TypeScript types.
Included usage examples in JS, showing both a simple WEBGL example and dynamic parameter updates.</p>
</li>
</ul>

<h2>Next steps at that point</h2>
<ul>
<li>
<p>The assistant had already given the user a <strong>working JS implementation</strong>.</p>
</li>
<li>
<p>The conversation ended right after sharing that, so the next steps would be for the user to:</p>
<ol>
<li>
<p><strong>Test the <code>P5.jsx</code> component</strong> in their React project.</p>
</li>
<li>
<p><strong>Verify behavior</strong>:</p>
<ul>
<li>
<p>Does <code>&lt;P5.Setup&gt;</code> correctly rebuild the instance when props change?</p>
</li>
<li>
<p>Does <code>&lt;P5.Draw&gt;</code> hot-swap properly without tearing the canvas?</p>
</li>
<li>
<p>Does the <code>useP5()</code> hook return expected refs?</p>
</li>
</ul>
</li>
<li>
<p>Decide whether they want refinements, such as:</p>
<ul>
<li>
<p>Handling resizing with <code>resizeCanvas</code> instead of full teardown.</p>
</li>
<li>
<p>Integrating on top of <code>@p5-wrapper/react</code> instead of direct <code>p5</code>.</p>
</li>
<li>
<p>Adding error boundaries or stricter prop validation.</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>

<p>✅ In short: the design was validated, improved, and implemented in JS. The next step is for you to integrate and test the <code>P5.jsx</code> component in your project, then refine behavior (resize handling, SSR guards, etc.) depending on your needs.</p>
<p>Do you want me to also give you a <strong>minimal starter React app</strong> (with package.json, App.jsx, etc.) that demonstrates the <code>P5.jsx</code> integration, so you can test it immediately?</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">OK great. No need for minimal starter React app.
Find attached the configuration files.
Next prompt will include the source code files.
Second next prompt will include the test code files.

No need for answer until I ask you a question.
Until then just load these assets to your context window.</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p class="first:mt-0 my-1.5 h-8 flex items-center ltr:me-auto rtl:ms-auto empty:hidden text-token-text-secondary"></p><p>Got it — I’ve loaded the configuration files (<code>babel.config.cjs</code>, <code>jest.config.cjs</code>, and <code>package.json</code>) into context. I’ll hold off on answering until you explicitly ask a question, and I’ll be ready to integrate these with the source and test files when you provide them.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Source code assets attached. Load them to your context window</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p class="first:mt-0 my-1.5 h-8 flex items-center ltr:me-auto rtl:ms-auto empty:hidden text-token-text-secondary"></p><p>✅ All your <strong>source code assets</strong> are now loaded into context:</p>
<ul>
<li>
<p><code>P5Canvas.jsx</code></p>
</li>
<li>
<p><code>P5Draw.jsx</code></p>
</li>
<li>
<p><code>P5Setup.jsx</code></p>
</li>
<li>
<p><code>CanvasContext.jsx</code></p>
</li>
<li>
<p><code>RegistryContext.jsx</code></p>
</li>
<li>
<p><code>useP5.js</code></p>
</li>
<li>
<p><code>useP5List.js</code></p>
</li>
<li>
<p><code>index.js</code></p>
</li>
</ul>
<p>I’ll hold on processing until you upload the <strong>test code files</strong> and ask your first question.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">Test code assets attached. Load them to your context window</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p class="first:mt-0 my-1.5 h-8 flex items-center ltr:me-auto rtl:ms-auto empty:hidden text-token-text-secondary"></p><p>✅ All your <strong>test code assets</strong> are now loaded into context:</p>
<ul>
<li>
<p>Integration tests:</p>
<ul>
<li>
<p><code>multi-canvas.test.jsx</code></p>
</li>
<li>
<p><code>resize.test.jsx</code></p>
</li>
</ul>
</li>
<li>
<p>Unit tests:</p>
<ul>
<li>
<p><code>P5Canvas.test.jsx</code></p>
</li>
<li>
<p><code>P5Draw.test.jsx</code></p>
</li>
<li>
<p><code>P5Setup.test.jsx</code></p>
</li>
<li>
<p><code>RegistryContext.test.jsx</code></p>
</li>
<li>
<p><code>useP5.test.jsx</code></p>
</li>
<li>
<p><code>useP5List.test.jsx</code></p>
</li>
</ul>
</li>
</ul>
<p>Everything is now staged in memory — configs, source, and tests.
I’ll wait for your explicit question before analyzing or responding further.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">OK, next step:
All our tests fail with <code>Cannot find module '../../../../../../src/lib/p5'</code>.
Can you show me how to configure jest to be able to load src/lib/p5 directly (akin to sys.path in python)?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’ve got two clean options. The simplest is to add a Jest alias so that any import starting with <code>src/</code> resolves from your project root.</p>
<h1>Option A — Add a <code>src/*</code> alias (recommended)</h1>
<p>Update <strong><code>jest.config.cjs</code></strong> to include a <code>moduleNameMapper</code> entry and (optionally) a <code>moduleDirectories</code> root:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// jest.config.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">'jsdom'</span>,
  <span class="hljs-comment">// If you already have "roots", keep them; otherwise this is fine</span>
  <span class="hljs-attr">roots</span>: [<span class="hljs-string">'&lt;rootDir&gt;/tests'</span>],

  <span class="hljs-comment">// 👇 Key bit: allow "src/..." absolute-style imports</span>
  <span class="hljs-attr">moduleNameMapper</span>: {
    <span class="hljs-string">'^src/(.*)$'</span>: <span class="hljs-string">'&lt;rootDir&gt;/src/$1'</span>,
    <span class="hljs-comment">// optional: style stubs if you ever import CSS in components</span>
    <span class="hljs-string">'\\.(css|less|scss|sass)$'</span>: <span class="hljs-string">'identity-obj-proxy'</span>,
  },

  <span class="hljs-comment">// Optional, but handy: lets Jest also resolve from project root</span>
  <span class="hljs-attr">moduleDirectories</span>: [<span class="hljs-string">'node_modules'</span>, <span class="hljs-string">'&lt;rootDir&gt;'</span>],

  <span class="hljs-attr">transform</span>: {
    <span class="hljs-string">'^.+\\.[jt]sx?$'</span>: <span class="hljs-string">'babel-jest'</span>,
  },

  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">'@testing-library/jest-dom'</span>],
};
</code></pre>
<p>With that in place, change your test imports from long relative paths like:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../../../../../../src/lib/p5"</span>;
</code></pre>
<p>to the clean alias:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;
</code></pre>
<p>(Your tests currently use those long paths in multiple files, e.g. <code>P5Canvas.test.jsx</code>, <code>P5Draw.test.jsx</code>, etc., so swap them to <code>src/lib/p5</code>.) </p>
<p>Your <strong><code>package.json</code></strong> already has <code>jest</code> and <code>babel-jest</code> wired, so this slots right in and you can continue running <code>npm test</code>. </p>
<h1>Option B — Use <code>moduleDirectories</code> only (no regex mapper)</h1>
<p>If you prefer not to use a regex mapper, you can let Jest treat <code>&lt;rootDir&gt;</code> as a resolution root:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// jest.config.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">'jsdom'</span>,
  <span class="hljs-attr">roots</span>: [<span class="hljs-string">'&lt;rootDir&gt;/tests'</span>],
  <span class="hljs-attr">moduleDirectories</span>: [<span class="hljs-string">'node_modules'</span>, <span class="hljs-string">'&lt;rootDir&gt;'</span>], <span class="hljs-comment">// 👈 makes "src/..." resolvable</span>
  <span class="hljs-attr">transform</span>: { <span class="hljs-string">'^.+\\.[jt]sx?$'</span>: <span class="hljs-string">'babel-jest'</span> },
  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">'@testing-library/jest-dom'</span>],
};
</code></pre>
<p>This also enables:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;
</code></pre>
<p>but the regex mapper (Option A) is more explicit and future-proof if you later add additional aliases.</p>

<h2>Quick sanity checklist</h2>
<ul>
<li>
<p>Keep your <strong>Babel config</strong> like:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// babel.config.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">presets</span>: [
    [<span class="hljs-string">'@babel/preset-env'</span>, { <span class="hljs-attr">targets</span>: { <span class="hljs-attr">node</span>: <span class="hljs-string">'current'</span> } }],
    [<span class="hljs-string">'@babel/preset-react'</span>, { <span class="hljs-attr">runtime</span>: <span class="hljs-string">'automatic'</span> }],
  ],
};
</code></pre>
</li>
<li>
<p>Ensure <code>src/lib/p5/index.js</code> indeed re-exports <code>{ P5, useP5, useP5List }</code> since your tests import from <code>src/lib/p5</code>. (Your tests expect that shape in multiple places.) </p>
</li>
</ul>
<p>Once you add Option A (or B) and switch your imports to <code>src/lib/p5</code>, the “Cannot find module '../../../../../../src/lib/p5'” failures should disappear.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">Great. Now I have an issue on the import of p5 (the library), I get 

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-stata">/Users/philippe/Documents/GitHub/concordia/cu-cart253/projects/art-jam-i/node_modules/p5/dist/<span class="hljs-keyword">app</span>.js:1
    import { p <span class="hljs-keyword">as</span> p5 } from './main-B3Z63C6j.js';
    ^^^^^^

    SyntaxError: Cannot <span class="hljs-keyword">use</span> import statement outside a module

...

Jest encountered <span class="hljs-keyword">an</span> unexpected <span class="hljs-keyword">token</span>

    Jest failed to <span class="hljs-keyword">parse</span> a <span class="hljs-keyword">file</span>. This happens <span class="hljs-keyword">e</span>.<span class="hljs-keyword">g</span>. when your code or its dependencies <span class="hljs-keyword">use</span> non-standard JavaScript <span class="hljs-keyword">syntax</span>, or when Jest is not configured to support such <span class="hljs-keyword">syntax</span>.

    <span class="hljs-keyword">Out</span> of the box Jest supports Babel, <span class="hljs-keyword">which</span> will be used to transform your files into valid JS based <span class="hljs-keyword">on</span> your Babel configuration.

    <span class="hljs-keyword">By</span> default <span class="hljs-string">"node_modules"</span> folder is ignored <span class="hljs-keyword">by</span> transformers.

    Here's what you can <span class="hljs-keyword">do</span>:
     • <span class="hljs-keyword">If</span> you are trying to <span class="hljs-keyword">use</span> ECMAScript Modules, see https:<span class="hljs-comment">//jestjs.io/docs/ecmascript-modules for how to enable it.</span>
     • <span class="hljs-keyword">If</span> you are trying to <span class="hljs-keyword">use</span> TypeScript, see https:<span class="hljs-comment">//jestjs.io/docs/getting-started#using-typescript</span>
     • To have some of your <span class="hljs-string">"node_modules"</span> files transformed, you can specify a custom <span class="hljs-string">"transformIgnorePatterns"</span> <span class="hljs-keyword">in</span> your config.
     • <span class="hljs-keyword">If</span> you need a custom transformation, specify a <span class="hljs-string">"transform"</span> option <span class="hljs-keyword">in</span> your config.
     • <span class="hljs-keyword">If</span> you simply want to mock your non-JS modules (<span class="hljs-keyword">e</span>.<span class="hljs-keyword">g</span>. binary assets) you can stub them <span class="hljs-keyword">out</span> with the <span class="hljs-string">"moduleNameMapper"</span> config option.

    You'll find <span class="hljs-keyword">more</span> details and examples of these config options <span class="hljs-keyword">in</span> the docs:
    https:<span class="hljs-comment">//jestjs.io/docs/configuration</span>
    <span class="hljs-keyword">For</span> information <span class="hljs-keyword">about</span> custom transformations, see:
    https:<span class="hljs-comment">//jestjs.io/docs/code-transformation</span></code></pre>

note that package.json:type is set to "module"</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’re running into an ESM-in-<code>node_modules</code> issue: <code>p5</code> ships as ESM (e.g., <code>dist/app.js</code>), while Jest (even v30) doesn’t transform <code>node_modules</code> by default—so it chokes on <code>import</code> there. Your code imports <code>p5</code> directly inside your canvas component, so tests will always load it.</p>
<p>You’ve got two clean fixes. I recommend <strong>mocking <code>p5</code> for tests</strong> (fast, stable, no rendering needed). If you prefer to execute real <code>p5</code>, use the <strong>transform exception</strong>.</p>

<h1>Fix 1 (recommended): Mock <code>p5</code> in tests</h1>
<ol>
<li>
<p>Create a manual mock the tests can use:</p>
</li>
</ol>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// tests/__mocks__/p5.js</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">P5</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">sketch, node</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">P2D</span> = <span class="hljs-string">"P2D"</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">WEBGL</span> = <span class="hljs-string">"WEBGL"</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_renderer</span> = { <span class="hljs-attr">GL</span>: { <span class="hljs-attr">RENDERER</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">P2D</span> } };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frameCount</span> = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// minimal API your code touches</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createCanvas</span> = <span class="hljs-function">(<span class="hljs-params">w, h, renderer</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_renderer</span>.<span class="hljs-property">GL</span>.<span class="hljs-property">RENDERER</span> = renderer === <span class="hljs-variable language_">this</span>.<span class="hljs-property">WEBGL</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">WEBGL</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">P2D</span>;
      <span class="hljs-keyword">const</span> elt = (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span> !== <span class="hljs-string">"undefined"</span>)
        ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"canvas"</span>)
        : { <span class="hljs-attr">nodeName</span>: <span class="hljs-string">"CANVAS"</span> };
      <span class="hljs-keyword">return</span> { elt };
    };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resizeCanvas</span> = <span class="hljs-function">() =&gt;</span> {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">noLoop</span> = <span class="hljs-function">() =&gt;</span> {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loop</span> = <span class="hljs-function">() =&gt;</span> {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remove</span> = <span class="hljs-function">() =&gt;</span> {};

    <span class="hljs-comment">// allow assigning/replacing draw</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_draw</span> = <span class="hljs-function">() =&gt;</span> {};
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"draw"</span>, {
      <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_draw</span>,
      <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> { <span class="hljs-variable language_">this</span>.<span class="hljs-property">_draw</span> = <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">"function"</span> ? fn : <span class="hljs-function">() =&gt;</span> {}; },
    });

    <span class="hljs-comment">// run the provided sketch</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> sketch === <span class="hljs-string">"function"</span>) {
      <span class="hljs-title function_">sketch</span>(<span class="hljs-variable language_">this</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">setup</span> === <span class="hljs-string">"function"</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setup</span>();
    }
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-variable constant_">P5</span>;
</code></pre>
<ol>
<li>
<p>Map the <code>p5</code> module to your mock in <strong><code>jest.config.cjs</code></strong>:</p>
</li>
</ol>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// jest.config.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">'jsdom'</span>,
  <span class="hljs-attr">roots</span>: [<span class="hljs-string">'&lt;rootDir&gt;/tests'</span>],
  <span class="hljs-attr">transform</span>: { <span class="hljs-string">'^.+\\.[jt]sx?$'</span>: <span class="hljs-string">'babel-jest'</span> },
  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">'@testing-library/jest-dom'</span>],
  <span class="hljs-attr">moduleNameMapper</span>: {
    <span class="hljs-string">'^src/(.*)$'</span>: <span class="hljs-string">'&lt;rootDir&gt;/src/$1'</span>,
    <span class="hljs-string">'^p5$'</span>: <span class="hljs-string">'&lt;rootDir&gt;/tests/__mocks__/p5.js'</span>, <span class="hljs-comment">// 👈 use mock in tests</span>
  },
  <span class="hljs-attr">moduleDirectories</span>: [<span class="hljs-string">'node_modules'</span>, <span class="hljs-string">'&lt;rootDir&gt;'</span>],
};
</code></pre>
<p>That’s it. Your tests won’t try to load the real ESM build of <code>p5</code>, and they’ll still exercise your React/p5 integration logic (registry, lifecycle, hot-swap draw, etc.). Your production code keeps using the real <code>p5</code> at runtime. Your project already has Jest/Babel wired in <code>package.json</code>.</p>

<h1>Fix 2 (alternate): Transform ESM <code>p5</code> from node_modules</h1>
<p>If you explicitly want the real <code>p5</code> running in Jest, allow Jest to transform it:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// jest.config.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">'jsdom'</span>,
  <span class="hljs-attr">roots</span>: [<span class="hljs-string">'&lt;rootDir&gt;/tests'</span>],
  <span class="hljs-attr">transform</span>: { <span class="hljs-string">'^.+\\.[jt]sx?$'</span>: <span class="hljs-string">'babel-jest'</span> },
  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">'@testing-library/jest-dom'</span>],
  <span class="hljs-attr">moduleNameMapper</span>: {
    <span class="hljs-string">'^src/(.*)$'</span>: <span class="hljs-string">'&lt;rootDir&gt;/src/$1'</span>,
  },
  <span class="hljs-attr">moduleDirectories</span>: [<span class="hljs-string">'node_modules'</span>, <span class="hljs-string">'&lt;rootDir&gt;'</span>],

  <span class="hljs-comment">// 👇 tell Jest NOT to ignore p5 when transforming node_modules</span>
  <span class="hljs-attr">transformIgnorePatterns</span>: [
    <span class="hljs-string">'node_modules/(?!(p5)/)'</span>, <span class="hljs-comment">// transpile p5 ESM</span>
  ],

  <span class="hljs-comment">// If you run into ESM interop edge cases:</span>
  <span class="hljs-comment">// extensionsToTreatAsEsm: ['.js', '.jsx'],</span>
};
</code></pre>
<p>And make sure <strong><code>babel.config.cjs</code></strong> can handle transforming ESM from <code>node_modules</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// babel.config.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">presets</span>: [
    [<span class="hljs-string">'@babel/preset-env'</span>, { <span class="hljs-attr">targets</span>: { <span class="hljs-attr">node</span>: <span class="hljs-string">'current'</span> } }],
    [<span class="hljs-string">'@babel/preset-react'</span>, { <span class="hljs-attr">runtime</span>: <span class="hljs-string">'automatic'</span> }],
  ],
};
</code></pre>
<p>This route is more brittle (you’re transpiling library code and any of its ESM chunks), but it works if you truly need the actual <code>p5</code> behavior under Jest.</p>

<h2>Which should you choose?</h2>
<ul>
<li>
<p><strong>Mock (Fix 1):</strong> Faster, simpler, avoids canvas/GL setups, perfect for your current tests (they assert registry/behavior, not pixels).</p>
</li>
<li>
<p><strong>Transform (Fix 2):</strong> Use only if you need to exercise real <code>p5</code> drawing in Jest (rare for unit/integration tests).</p>
</li>
</ul>
<p>If you want, I can add a tiny assertion to your tests to confirm the mock exposes <code>P2D/WEBGL</code> and that <code>renderer</code> changes trigger recreate as expected.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">Great. I have decided to go the Mock approach because as you stated, we don't need to have p5js load as we don't test p5 functionalities using automated testing (and it is in fact preferable not to load the dependency). This may turn out to be a problem if we end up writing unit tests for p5 canvas down the line (such as snapshot tests in a browser), but I don't expect that to be the case; if we come to that we'll revise then.

This being said,

Here's the result of the tests:

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-gradle">npm run test

&gt; art-jam-i@<span class="hljs-number">0.0</span>.<span class="hljs-number">0</span> test
&gt; jest

 PASS  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>context/RegistryContext.test.jsx
 PASS  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>components/P5Draw.test.jsx
 PASS  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>components/P5Setup.test.jsx
 PASS  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/integration/</span>resize.test.jsx
 FAIL  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/integration/mu</span>lti-canvas.test.jsx
  ● integration: multiple canvases › registers multiple canvases in registry

    TypeError: Cannot <span class="hljs-keyword">read</span> properties of undefined (reading <span class="hljs-string">'$$typeof'</span>)

      <span class="hljs-number">4</span> | <span class="hljs-comment">/** Returns an array of registered canvas IDs. */</span>
      <span class="hljs-number">5</span> | export function useP5List() {
    &gt; <span class="hljs-number">6</span> |   const regCtx = useContext(RegistryCtx);
        |                            ^
      <span class="hljs-number">7</span> |   <span class="hljs-keyword">if</span> (!regCtx) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"useP5List must be used inside &lt;P5.ContextProvider&gt;."</span>);
      <span class="hljs-number">8</span> |   <span class="hljs-keyword">return</span> useMemo(() =&gt; Array.<span class="hljs-keyword">from</span>(regCtx.registry.keys()), [regCtx.registry]);
      <span class="hljs-number">9</span> | }

      at process.env.NODE_ENV.exports.useContext (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">1165</span>:<span class="hljs-number">15</span>)
      at useP5List (src<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/hooks/u</span>seP5List.js:<span class="hljs-number">6</span>:<span class="hljs-number">28</span>)
      at ListIds (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/integration/mu</span>lti-canvas.test.jsx:<span class="hljs-number">6</span>:<span class="hljs-number">24</span>)
      at Object.react_stack_bottom_frame (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">23863</span>:<span class="hljs-number">20</span>)
      at renderWithHooks (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">5529</span>:<span class="hljs-number">22</span>)
      at updateFunctionComponent (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">8897</span>:<span class="hljs-number">19</span>)
      at beginWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">10522</span>:<span class="hljs-number">18</span>)
      at runWithFiberInDEV (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">1522</span>:<span class="hljs-number">13</span>)
      at performUnitOfWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">15140</span>:<span class="hljs-number">22</span>)
      at workLoopSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14956</span>:<span class="hljs-number">41</span>)
      at renderRootSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14936</span>:<span class="hljs-number">11</span>)
      at performWorkOnRoot (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14462</span>:<span class="hljs-number">44</span>)
      at performWorkOnRootViaSchedulerTask (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">16216</span>:<span class="hljs-number">7</span>)
      at flushActQueue (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">566</span>:<span class="hljs-number">34</span>)
      at process.env.NODE_ENV.exports.act (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">860</span>:<span class="hljs-number">10</span>)
      at node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>act-compat.js:<span class="hljs-number">47</span>:<span class="hljs-number">25</span>
      at renderRoot (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">190</span>:<span class="hljs-number">26</span>)
      at render (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">292</span>:<span class="hljs-number">10</span>)
      at Object.&lt;anonymous&gt; (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/integration/mu</span>lti-canvas.test.jsx:<span class="hljs-number">12</span>:<span class="hljs-number">35</span>)

 FAIL  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5.test.jsx
  ● useP5 hook › <span class="hljs-keyword">throws</span> <span class="hljs-keyword">if</span> used outside provider

    useP5 must be used inside &lt;P5.ContextProvider&gt;.

       <span class="hljs-number">8</span> | export function useP5(id) {
       <span class="hljs-number">9</span> |   const regCtx = useContext(RegistryContext);
    &gt; <span class="hljs-number">10</span> |   <span class="hljs-keyword">if</span> (!regCtx) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"useP5 must be used inside &lt;P5.ContextProvider&gt;."</span>);
         |                      ^
      <span class="hljs-number">11</span> |
      <span class="hljs-number">12</span> |   const { registry } = regCtx;
      <span class="hljs-number">13</span> |

      at useP5 (src<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/hooks/u</span>seP5.js:<span class="hljs-number">10</span>:<span class="hljs-number">22</span>)
      at tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5.test.jsx:<span class="hljs-number">7</span>:<span class="hljs-number">46</span>
      at TestComponent (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">331</span>:<span class="hljs-number">27</span>)
      at Object.react_stack_bottom_frame (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">23863</span>:<span class="hljs-number">20</span>)
      at renderWithHooks (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">5529</span>:<span class="hljs-number">22</span>)
      at updateFunctionComponent (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">8897</span>:<span class="hljs-number">19</span>)
      at beginWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">10522</span>:<span class="hljs-number">18</span>)
      at runWithFiberInDEV (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">1522</span>:<span class="hljs-number">13</span>)
      at performUnitOfWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">15140</span>:<span class="hljs-number">22</span>)
      at workLoopSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14956</span>:<span class="hljs-number">41</span>)
      at renderRootSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14936</span>:<span class="hljs-number">11</span>)
      at performWorkOnRoot (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14462</span>:<span class="hljs-number">44</span>)
      at performWorkOnRootViaSchedulerTask (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">16216</span>:<span class="hljs-number">7</span>)
      at flushActQueue (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">566</span>:<span class="hljs-number">34</span>)
      at process.env.NODE_ENV.exports.act (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">860</span>:<span class="hljs-number">10</span>)
      at node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>act-compat.js:<span class="hljs-number">47</span>:<span class="hljs-number">25</span>
      at renderRoot (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">190</span>:<span class="hljs-number">26</span>)
      at render (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">292</span>:<span class="hljs-number">10</span>)
      at renderHook (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">340</span>:<span class="hljs-number">7</span>)
      at Object.&lt;anonymous&gt; (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5.test.jsx:<span class="hljs-number">7</span>:<span class="hljs-number">34</span>)

 FAIL  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5List.test.jsx
  ● useP5List hook › <span class="hljs-keyword">throws</span> <span class="hljs-keyword">if</span> used outside provider

    TypeError: Cannot <span class="hljs-keyword">read</span> properties of undefined (reading <span class="hljs-string">'$$typeof'</span>)

      <span class="hljs-number">4</span> | <span class="hljs-comment">/** Returns an array of registered canvas IDs. */</span>
      <span class="hljs-number">5</span> | export function useP5List() {
    &gt; <span class="hljs-number">6</span> |   const regCtx = useContext(RegistryCtx);
        |                            ^
      <span class="hljs-number">7</span> |   <span class="hljs-keyword">if</span> (!regCtx) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"useP5List must be used inside &lt;P5.ContextProvider&gt;."</span>);
      <span class="hljs-number">8</span> |   <span class="hljs-keyword">return</span> useMemo(() =&gt; Array.<span class="hljs-keyword">from</span>(regCtx.registry.keys()), [regCtx.registry]);
      <span class="hljs-number">9</span> | }

      at process.env.NODE_ENV.exports.useContext (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">1165</span>:<span class="hljs-number">15</span>)
      at useP5List (src<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/hooks/u</span>seP5List.js:<span class="hljs-number">6</span>:<span class="hljs-number">28</span>)
      at tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5List.test.jsx:<span class="hljs-number">7</span>:<span class="hljs-number">50</span>
      at TestComponent (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">331</span>:<span class="hljs-number">27</span>)
      at Object.react_stack_bottom_frame (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">23863</span>:<span class="hljs-number">20</span>)
      at renderWithHooks (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">5529</span>:<span class="hljs-number">22</span>)
      at updateFunctionComponent (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">8897</span>:<span class="hljs-number">19</span>)
      at beginWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">10522</span>:<span class="hljs-number">18</span>)
      at runWithFiberInDEV (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">1522</span>:<span class="hljs-number">13</span>)
      at performUnitOfWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">15140</span>:<span class="hljs-number">22</span>)
      at workLoopSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14956</span>:<span class="hljs-number">41</span>)
      at renderRootSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14936</span>:<span class="hljs-number">11</span>)
      at performWorkOnRoot (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14462</span>:<span class="hljs-number">44</span>)
      at performWorkOnRootViaSchedulerTask (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">16216</span>:<span class="hljs-number">7</span>)
      at flushActQueue (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">566</span>:<span class="hljs-number">34</span>)
      at process.env.NODE_ENV.exports.act (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">860</span>:<span class="hljs-number">10</span>)
      at node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>act-compat.js:<span class="hljs-number">47</span>:<span class="hljs-number">25</span>
      at renderRoot (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">190</span>:<span class="hljs-number">26</span>)
      at render (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">292</span>:<span class="hljs-number">10</span>)
      at renderHook (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">340</span>:<span class="hljs-number">7</span>)
      at Object.&lt;anonymous&gt; (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5List.test.jsx:<span class="hljs-number">7</span>:<span class="hljs-number">34</span>)

  ● useP5List hook › returns [] with no canvases

    TypeError: Cannot <span class="hljs-keyword">read</span> properties of undefined (reading <span class="hljs-string">'$$typeof'</span>)

      <span class="hljs-number">4</span> | <span class="hljs-comment">/** Returns an array of registered canvas IDs. */</span>
      <span class="hljs-number">5</span> | export function useP5List() {
    &gt; <span class="hljs-number">6</span> |   const regCtx = useContext(RegistryCtx);
        |                            ^
      <span class="hljs-number">7</span> |   <span class="hljs-keyword">if</span> (!regCtx) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"useP5List must be used inside &lt;P5.ContextProvider&gt;."</span>);
      <span class="hljs-number">8</span> |   <span class="hljs-keyword">return</span> useMemo(() =&gt; Array.<span class="hljs-keyword">from</span>(regCtx.registry.keys()), [regCtx.registry]);
      <span class="hljs-number">9</span> | }

      at process.env.NODE_ENV.exports.useContext (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">1165</span>:<span class="hljs-number">15</span>)
      at useP5List (src<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/hooks/u</span>seP5List.js:<span class="hljs-number">6</span>:<span class="hljs-number">28</span>)
      at wrapper.wrapper (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5List.test.jsx:<span class="hljs-number">13</span>:<span class="hljs-number">50</span>)
      at TestComponent (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">331</span>:<span class="hljs-number">27</span>)
      at Object.react_stack_bottom_frame (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">23863</span>:<span class="hljs-number">20</span>)
      at renderWithHooks (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">5529</span>:<span class="hljs-number">22</span>)
      at updateFunctionComponent (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">8897</span>:<span class="hljs-number">19</span>)
      at beginWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">10522</span>:<span class="hljs-number">18</span>)
      at runWithFiberInDEV (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">1522</span>:<span class="hljs-number">13</span>)
      at performUnitOfWork (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">15140</span>:<span class="hljs-number">22</span>)
      at workLoopSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14956</span>:<span class="hljs-number">41</span>)
      at renderRootSync (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14936</span>:<span class="hljs-number">11</span>)
      at performWorkOnRoot (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">14462</span>:<span class="hljs-number">44</span>)
      at performWorkOnRootViaSchedulerTask (node_modules<span class="hljs-regexp">/react-dom/</span>cjs/react-dom-client.development.js:<span class="hljs-number">16216</span>:<span class="hljs-number">7</span>)
      at flushActQueue (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">566</span>:<span class="hljs-number">34</span>)
      at process.env.NODE_ENV.exports.act (node_modules<span class="hljs-regexp">/react/</span>cjs/react.development.js:<span class="hljs-number">860</span>:<span class="hljs-number">10</span>)
      at node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>act-compat.js:<span class="hljs-number">47</span>:<span class="hljs-number">25</span>
      at renderRoot (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">190</span>:<span class="hljs-number">26</span>)
      at render (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">292</span>:<span class="hljs-number">10</span>)
      at renderHook (node_modules<span class="hljs-regexp">/@testing-library/</span>react<span class="hljs-regexp">/dist/</span>pure.js:<span class="hljs-number">340</span>:<span class="hljs-number">7</span>)
      at Object.&lt;anonymous&gt; (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>hooks/useP5List.test.jsx:<span class="hljs-number">13</span>:<span class="hljs-number">34</span>)

 FAIL  tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>components/P5Canvas.test.jsx
  ● &lt;P5.Canvas&gt; › renders a <span class="hljs-keyword">div</span> container

    TestingLibraryElementError: Found multiple elements with the role <span class="hljs-string">"generic"</span>

    Here are the matching elements:

    Ignored nodes: comments, script, style
    &lt;<span class="hljs-keyword">div</span>&gt;
      &lt;<span class="hljs-keyword">div</span> /&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;

    Ignored nodes: comments, script, style
    &lt;<span class="hljs-keyword">div</span> /&gt;

    (<span class="hljs-keyword">If</span> <span class="hljs-keyword">this</span> is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).

    Ignored nodes: comments, script, style
    &lt;body&gt;
      &lt;<span class="hljs-keyword">div</span>&gt;
        &lt;<span class="hljs-keyword">div</span> /&gt;
      &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;/body&gt;

      <span class="hljs-number">13</span> |     );
      <span class="hljs-number">14</span> |
    &gt; <span class="hljs-number">15</span> |     const <span class="hljs-keyword">div</span> = screen.getByRole(<span class="hljs-string">"generic"</span>);
         |                        ^
      <span class="hljs-number">16</span> |     expect(<span class="hljs-keyword">div</span>).toBeInTheDocument();
      <span class="hljs-number">17</span> |   });
      <span class="hljs-number">18</span> |

      at Object.getElementError (node_modules<span class="hljs-regexp">/@testing-library/</span>dom<span class="hljs-regexp">/dist/</span>config.js:<span class="hljs-number">37</span>:<span class="hljs-number">19</span>)
      at getElementError (node_modules<span class="hljs-regexp">/@testing-library/</span>dom<span class="hljs-regexp">/dist/</span>query-helpers.js:<span class="hljs-number">20</span>:<span class="hljs-number">35</span>)
      at getMultipleElementsFoundError (node_modules<span class="hljs-regexp">/@testing-library/</span>dom<span class="hljs-regexp">/dist/</span>query-helpers.js:<span class="hljs-number">23</span>:<span class="hljs-number">10</span>)
      at node_modules<span class="hljs-regexp">/@testing-library/</span>dom<span class="hljs-regexp">/dist/</span>query-helpers.js:<span class="hljs-number">55</span>:<span class="hljs-number">13</span>
      at node_modules<span class="hljs-regexp">/@testing-library/</span>dom<span class="hljs-regexp">/dist/</span>query-helpers.js:<span class="hljs-number">95</span>:<span class="hljs-number">19</span>
      at Object.getByRole (tests<span class="hljs-regexp">/lib/</span>p5<span class="hljs-regexp">/unit/</span>components/P5Canvas.test.jsx:<span class="hljs-number">15</span>:<span class="hljs-number">24</span>)

Test Suites: <span class="hljs-number">4</span> failed, <span class="hljs-number">4</span> passed, <span class="hljs-number">8</span> total
Tests:       <span class="hljs-number">5</span> failed, <span class="hljs-number">7</span> passed, <span class="hljs-number">12</span> total
Snapshots:   <span class="hljs-number">0</span> total
Time:        <span class="hljs-number">1.082</span> s
Ran all test suites.</code></pre></div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Nice progress—mocking <code>p5</code> was the right call. Your remaining failures come from two issues:</p>
<ol>
<li>
<p>a small bug in <code>useP5List</code> (wrong context symbol), and</p>
</li>
<li>
<p>an over-broad query in one test that finds multiple <code>&lt;div role="generic"&gt;</code>.</p>
</li>
</ol>
<p>Here’s how to get everything green.</p>

<h1>1) Fix <code>useP5List</code> to use the right context</h1>
<p>Your error shows <code>useP5List</code> calling <code>useContext(RegistryCtx)</code> (undefined), so React tries to read <code>$$typeof</code> from <code>undefined</code> and explodes. Swap it to use the actual exported context (<code>RegistryContext</code>) and import it from the right place.</p>
<p><strong><code>src/lib/p5/hooks/useP5List.js</code></strong></p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">-import { useContext, useMemo } from "react";</span>
<span class="hljs-deletion">-// ❌ likely wrong import/name:</span>
<span class="hljs-deletion">-// import { RegistryCtx } from "../context/RegistryContext";</span>
<span class="hljs-addition">+import { useContext, useMemo } from "react";</span>
<span class="hljs-addition">+import { RegistryContext } from "../context/RegistryContext";</span>

 /** Returns an array of registered canvas IDs. */
 export function useP5List() {
<span class="hljs-deletion">-  const regCtx = useContext(RegistryCtx);</span>
<span class="hljs-addition">+  const regCtx = useContext(RegistryContext);</span>
   if (!regCtx) throw new Error("useP5List must be used inside &lt;P5.ContextProvider&gt;.");
   return useMemo(() =&gt; Array.from(regCtx.registry.keys()), [regCtx.registry]);
 }
</code></pre>
<p>This directly addresses the stack traces you posted for both the integration test and the hook unit test that mention <code>useP5List.js:6</code> and the <code>$$typeof</code> read.</p>

<h1>2) Make the <code>&lt;P5.Canvas&gt;</code> test query unambiguous</h1>
<p><code>getByRole("generic")</code> returns <strong>multiple</strong> candidates (Testing Library’s root container <code>&lt;div&gt;</code> plus your canvas host <code>&lt;div&gt;</code>), hence the failure.</p>
<p>Two easy fixes (pick one):</p>
<p><strong>A. Narrow the query in the test (minimal change):</strong></p>
<p><strong><code>tests/lib/p5/unit/components/P5Canvas.test.jsx</code></strong></p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">-const div = screen.getByRole("generic");</span>
<span class="hljs-deletion">-expect(div).toBeInTheDocument();</span>
<span class="hljs-addition">+const divs = screen.getAllByRole("generic");</span>
<span class="hljs-addition">+expect(divs.length).toBeGreaterThan(0);</span>
<span class="hljs-addition">+// Optionally assert that one of them is an empty DIV host</span>
<span class="hljs-addition">+// expect(divs.some(d =&gt; d.tagName === "DIV")).toBe(true);</span>
</code></pre>
<p><strong>B. Or, add a test id in the component (if you prefer stable targeting):</strong></p>
<p><strong><code>src/lib/p5/components/P5Canvas.jsx</code></strong></p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">-  return (</span>
<span class="hljs-deletion">-    &lt;CanvasContext.Provider value={canvasCtxValue}&gt;</span>
<span class="hljs-deletion">-      &lt;div ref={hostDivRef} className={className} style={style} suppressHydrationWarning /&gt;</span>
<span class="hljs-deletion">-      {renderedChildren}</span>
<span class="hljs-deletion">-    &lt;/CanvasContext.Provider&gt;</span>
<span class="hljs-deletion">-  );</span>
<span class="hljs-addition">+  return (</span>
<span class="hljs-addition">+    &lt;CanvasContext.Provider value={canvasCtxValue}&gt;</span>
<span class="hljs-addition">+      &lt;div</span>
<span class="hljs-addition">+        ref={hostDivRef}</span>
<span class="hljs-addition">+        data-testid={`p5-host-${id}`}</span>
<span class="hljs-addition">+        className={className}</span>
<span class="hljs-addition">+        style={style}</span>
<span class="hljs-addition">+        suppressHydrationWarning</span>
<span class="hljs-addition">+      /&gt;</span>
<span class="hljs-addition">+      {renderedChildren}</span>
<span class="hljs-addition">+    &lt;/CanvasContext.Provider&gt;</span>
<span class="hljs-addition">+  );</span>
</code></pre>
<p>…and then in the test:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">-const div = screen.getByRole("generic");</span>
<span class="hljs-addition">+const div = screen.getByTestId("p5-host-foo");</span>
 expect(div).toBeInTheDocument();
</code></pre>
<p>I’d go with <strong>A</strong> (test-only change) to avoid touching runtime code.</p>

<h1>3) (Optional) Make the “throws outside provider” hook test robust</h1>
<p>React 19 + Testing Library sometimes surfaces thrown errors noisily. Your current test should work, but to be extra robust you can assert with <code>toThrow</code>:</p>
<p><strong><code>tests/lib/p5/unit/hooks/useP5.test.jsx</code></strong></p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">-it("throws if used outside provider", () =&gt; {</span>
<span class="hljs-deletion">-  const { result } = renderHook(() =&gt; useP5("foo"));</span>
<span class="hljs-deletion">-  expect(result.error).toBeTruthy();</span>
<span class="hljs-deletion">-});</span>
<span class="hljs-addition">+it("throws if used outside provider", () =&gt; {</span>
<span class="hljs-addition">+  expect(() =&gt; renderHook(() =&gt; useP5("foo"))).toThrow(</span>
<span class="hljs-addition">+    /useP5 must be used inside &lt;P5\.ContextProvider&gt;/</span>
<span class="hljs-addition">+  );</span>
<span class="hljs-addition">+});</span>
</code></pre>
<p>(This isn’t strictly required if your current pattern behaves on your setup, but it eliminates any ambiguity.)</p>

<h1>4) Quick sanity checks</h1>
<ul>
<li>
<p>Your index barrel should export the hook symbols the tests import (it looks like they do):</p>
<ul>
<li>
<p><code>import { P5, useP5 } from "src/lib/p5";</code></p>
</li>
<li>
<p><code>import { P5, useP5List } from "src/lib/p5";</code></p>
</li>
</ul>
</li>
<li>
<p>The provider/registry look solid: <code>ContextProvider</code> supplies <code>{ registry, registerCanvas, updateCanvas, unregisterCanvas }</code>; <code>P5.Canvas</code> registers/unregisters and keeps size updated.</p>
</li>
</ul>
<p>Apply the <code>useP5List</code> fix and the test query tweak, and your failing suites should flip to ✅.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">(1) Fixed; was an oversight when I refactored
(2) I picked test-id because that's best practice in production-grade applications
(3) Fixed using provided fix; extended the fix to useP5List
(4) No changes applied - if you proposed some changes, please reexplain the changes you are expecting. Seemed like a LGTM.

All tests now pass.</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Boom—nice work. 🎯 Congrats on getting the suite green.</p>
<p>A couple of tidy follow-ups you might consider (totally optional):</p>
<ol>
<li>
<p>Auto-use the mock only in tests
If you haven’t already, keep the <code>p5</code> mock mapping scoped to Jest so prod builds always pull real <code>p5</code>:</p>
<ul>
<li>
<p>Keep <code>'^p5$': '&lt;rootDir&gt;/tests/__mocks__/p5.js'</code> only in <code>jest.config.cjs</code> (not in bundler aliases).</p>
</li>
</ul>
</li>
<li>
<p>Barrel exports sanity
Your tests import <code>{ P5, useP5, useP5List }</code> from <code>src/lib/p5</code>—just make sure the barrel re-exports those consistently (it looks good given the test imports).</p>
</li>
<li>
<p>Test IDs done right
Using a dedicated <code>data-testid</code> on the host div is perfect for the canvas unit test; it avoids role collisions and reads clearly in future refactors. You already applied this pattern to your test—nice.</p>
</li>
<li>
<p>(Optional) Micro-hardening in <code>Canvas</code>
You already included <code>suppressHydrationWarning</code> on the host for SSR safety. If you ever server-render, you can add a quick runtime guard so the p5 instance only spins up client-side (e.g., gate the <code>new p5js(...)</code> effect behind <code>typeof window !== 'undefined'</code>). Not required for your current setup, just a future-proofing note.</p>
</li>
<li>
<p>Registry hooks LGTM
The <code>RegistryContext</code> shape and updates look clean (register/update/unregister), and your <code>useP5List</code> fix (using the right context) resolves the <code>$$typeof</code> error paths from the failing tests.</p>
</li>
</ol>
<p>If you want, I can bundle a tiny <code>CONTRIBUTING.md</code> test section (jest alias, <code>p5</code> mock rationale, how to add new tests) so future you doesn’t have to re-remember these details.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">No need for a CONTRIBUTING.md; this being said, I would like a README.md for the src/lib/p5 directory that states the advantages/rationale of the design proposed over @p5-wrapper/react, including, but not limited to:

- Declarative API;
- Hot-swap draw function for multiple-scene support
- Multiple p5 instance support
- Ability to use React state/HTML interactivity to control p5 state; ability to create declarative data model
- Ease of integration in existing React applications; Extends p5 functionalities to support industry standard network requests/caching, etc, with examples (including easy support for real-time/websocket interactions for multiplayer)

Also, provide:
- any disadvantages you may think of; 
- any limitations
- basic introductory documentation on how to use this lib/p5 directory
- attribution to yourself as primary implementer and myself as primary architect; also that the exact conversations that produced the code are available under src/lib/p5/ATTRIBUTION/*.html
- any other standard sections to be expected in an industry-standard readme for a react/frontend lib. No need to include test coverage/result/badges.
</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Here’s a solid <strong>README.md</strong> draft tailored for <code>src/lib/p5</code> in your repo. It’s written in the tone of an industry-standard open source frontend library, with rationale, usage, pros/cons, and attribution. You can drop this into <code>src/lib/p5/README.md</code>.</p>

<pre class="overflow-visible!"><code class="whitespace-pre! language-markdown code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-section"># React-P5 Declarative Integration</span>

This package provides a <span class="hljs-strong">**declarative React integration for p5.js**</span>, designed as a more flexible and composable alternative to [<span class="hljs-string">`@p5-wrapper/react`</span>](<span class="hljs-link">https://github.com/p5-wrapper/react</span>).

It enables you to use <span class="hljs-code">`p5`</span> sketches directly inside React applications in a way that feels idiomatic: components, hooks, and context providers rather than imperative setup.

---

<span class="hljs-section">## ✨ Key Advantages Over `@p5-wrapper/react`</span>

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Declarative API**</span>  
  Define <span class="hljs-code">`&lt;P5.Setup&gt;`</span> and <span class="hljs-code">`&lt;P5.Draw&gt;`</span> directly inside JSX. Lifecycle is tied to React’s reconciliation, not imperative re-instantiation.

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Hot-swap draw functions**</span>  
  Replace <span class="hljs-code">`&lt;P5.Draw fn={...} /&gt;`</span> on the fly without tearing down the canvas. Enables <span class="hljs-strong">**multi-scene**</span> workflows and interactive transitions.

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Multiple p5 instance support**</span>  
  Use <span class="hljs-code">`&lt;P5.Canvas id="..."&gt;`</span> to mount multiple independent canvases. Each canvas is registered in global context for hooks and management.

<span class="hljs-bullet">-</span> <span class="hljs-strong">**React state &amp; interactivity**</span>  
  Pass <span class="hljs-code">`params`</span> into setup/draw functions. Combine with React state, props, or context to declaratively control visual state. Ideal for building <span class="hljs-strong">**data models**</span> or <span class="hljs-strong">**state-driven scenes**</span>.

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Easy integration in React apps**</span>  
  Fits into existing component trees and tooling (Vite, Babel, Jest). Plays nicely with standard React patterns (hooks, context, state).

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Extends p5 with modern app features**</span>  
  Because you are in React, you can seamlessly integrate:  
<span class="hljs-bullet">  -</span> Network requests (REST, GraphQL, etc.)  
<span class="hljs-bullet">  -</span> Local caching and persistence (React Query, SWR)  
<span class="hljs-bullet">  -</span> Real-time multiplayer via WebSockets or WebRTC  

  <span class="hljs-code">```jsx
  import { P5 } from "src/lib/p5";
  import { useState, useEffect } from "react";

  function MultiplayerCanvas({ socket }) {
    const [players, setPlayers] = useState({});

    useEffect(() =&gt; {
      socket.on("players:update", (payload) =&gt; setPlayers(payload));
    }, [socket]);

    return (
      &lt;P5.Canvas id="game" width={800} height={600} renderer="WEBGL"&gt;
        &lt;P5.Setup fn={(p5) =&gt; p5.background(0)} /&gt;
        &lt;P5.Draw fn={(p5) =&gt; {
          p5.background(0);
          Object.values(players).forEach(({ x, y }) =&gt; {
            p5.ellipse(x, y, 20, 20);
          });
        }} /&gt;
      &lt;/P5.Canvas&gt;
    );
  }
</span></code></pre>

<h2>📦 Installation</h2>
<p>This code lives inside your project under <code>src/lib/p5</code>.
No npm install step is required, but you do need <code>p5</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-bash code-block hljs" style="display: block;" data-highlighted="yes">npm install p5
</code></pre>

<h2>🚀 Basic Usage</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> p5.background(200)} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> {
          p5.background(200);
          p5.ellipse(p5.width / 2, p5.height / 2, 50, 50);
        }} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<h3>Hooks</h3>
<ul>
<li>
<p><code>useP5(id)</code> → access <code>{ ready, p5Ref, canvasRef, size }</code> for a specific canvas</p>
</li>
<li>
<p><code>useP5List()</code> → get an array of all registered canvas IDs</p>
</li>
</ul>

<h2>⚠️ Limitations &amp; Disadvantages</h2>
<ul>
<li>
<p><strong>SSR caveats</strong>: p5 requires DOM APIs. This lib guards against hydration mismatches, but server-side rendering won’t render sketches. Use <code>typeof window !== "undefined"</code> to defer if needed.</p>
</li>
<li>
<p><strong>No pixel snapshots in tests</strong>: The Jest setup mocks p5. Automated tests validate lifecycle/registry logic, not actual rendering output.</p>
</li>
<li>
<p><strong>Draw hot-swap is one-at-a-time</strong>: Only the most recent <code>&lt;P5.Draw&gt;</code> child defines <code>draw</code>. You can replace dynamically but not run multiple draws in parallel.</p>
</li>
<li>
<p><strong>Canvas resize vs recreate</strong>: Changing <code>width/height</code> resizes, but changing renderer (<code>P2D</code> ↔ <code>WEBGL</code>) forces a full re-create.</p>
</li>
</ul>

<h2>📖 API Reference</h2>
<h3><code>&lt;P5.ContextProvider&gt;</code></h3>
<p>Global registry provider. Wrap once near the root of your app.</p>
<h3><code>&lt;P5.Canvas id width height renderer className style&gt;</code></h3>
<p>Mount a p5 canvas.</p>
<ul>
<li>
<p><code>id</code> (string) – required, unique</p>
</li>
<li>
<p><code>width</code>, <code>height</code> (number) – canvas size</p>
</li>
<li>
<p><code>renderer</code> (<code>"P2D" | "WEBGL"</code>) – defaults to <code>"P2D"</code></p>
</li>
</ul>
<h3><code>&lt;P5.Setup fn params /&gt;</code></h3>
<p>One-time setup function. Changing <code>fn</code> triggers full canvas recreate.</p>
<h3><code>&lt;P5.Draw fn params /&gt;</code></h3>
<p>Draw loop function. Changing <code>fn</code> hot-swaps without recreate.</p>
<h3><code>useP5(id)</code></h3>
<p>Access registry entry for a given canvas:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-ts code-block hljs language-typescript" style="display: block;" data-highlighted="yes">{
  <span class="hljs-attr">ready</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">p5Ref</span>: <span class="hljs-title class_">Ref</span>&lt;p5|<span class="hljs-literal">null</span>&gt;;
  <span class="hljs-attr">canvasRef</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-title class_">HTMLCanvasElement</span>|<span class="hljs-literal">null</span>&gt;;
  <span class="hljs-attr">size</span>: { <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span> };
}
</code></pre>
<h3><code>useP5List()</code></h3>
<p>Returns all registered canvas IDs.</p>

<h2>👥 Attribution</h2>
<ul>
<li>
<p><strong>Primary Architect</strong>: Philippe Hébert</p>
</li>
<li>
<p><strong>Primary Implementer</strong>: ChatGPT (OpenAI)</p>
</li>
<li>
<p>Original design rationale and conversation logs are available in:
<code>src/lib/p5/ATTRIBUTION/*.html</code></p>
</li>
</ul>

<h2>📄 License</h2>
<p>MIT (same as project root unless otherwise specified).</p>
<pre class="overflow-visible!"><code class="whitespace-pre! code-block hljs language-pgsql" style="display: block;" data-highlighted="yes">
<span class="hljs-comment">---</span>

Would you <span class="hljs-keyword">like</span> me <span class="hljs-keyword">to</span> <span class="hljs-keyword">also</span> draft a **short example section** <span class="hljs-keyword">on</span> <span class="hljs-keyword">using</span> React state <span class="hljs-keyword">with</span> `&lt;P5.Draw&gt;` (e.g., controlled <span class="hljs-keyword">by</span> a slider <span class="hljs-keyword">input</span>) <span class="hljs-keyword">to</span> demonstrate HTML ↔ p5 interaction, <span class="hljs-keyword">or</span> <span class="hljs-keyword">is</span> the multiplayer/WebSocket example enough?
</code></pre></div>
        </div>
      
        <div class="message user-message">
          <div class="content">OK, great, let's now fix issues:

Given:

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">{ count = <span class="hljs-number">0</span> }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> {
          p5.randomSeed(99);
          p5.background(200)
        }} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> {
          p5.background(200);
          for (let i = 0; i &lt;= count + 1; i++) {
            //p5.ellipse(p5.random(25, 175), p5.random(25, 175) + p5.sin(p5.frameCount * 0.05), 50, 50);
            p5.ellipse(25, 35 + 10*p5.sin(p5.frameCount * 0.05), 50, 50);
          }
          
        }} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}</code></pre>

with a fixed <code>p5.randomSeed(99);</code>, it seems like <code>p5.random(25, 175)</code> is not stable.

Can you explain possible causes, and suggest an how to fix?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Yep — this is a classic <strong>p5.js random reproducibility gotcha</strong>.</p>

<h2>Why <code>p5.randomSeed(99)</code> isn’t making your <code>random()</code> stable</h2>
<ol>
<li>
<p><strong>Where you call <code>randomSeed</code> matters</strong></p>
<ul>
<li>
<p>You’re calling <code>p5.randomSeed(99)</code> inside <strong><code>setup</code></strong> (via <code>&lt;P5.Setup&gt;</code>).</p>
</li>
<li>
<p>That only sets the seed <em>once at the beginning</em>.</p>
</li>
<li>
<p>After that, every call to <code>p5.random()</code> advances the PRNG state.</p>
</li>
<li>
<p>Since you’re calling <code>random()</code> <strong>every frame</strong> in <code>draw()</code>, you’ll get a different random number each frame. That’s expected behavior.</p>
</li>
</ul>
</li>
<li>
<p><strong>Deterministic across runs, not across frames</strong></p>
<ul>
<li>
<p><code>randomSeed(99)</code> ensures that the <em>sequence</em> of numbers is repeatable if you replay the sketch from the start.</p>
</li>
<li>
<p>But within a single run, the numbers are supposed to vary as you call <code>random()</code>.</p>
</li>
<li>
<p>So if you restart the sketch, you’ll always get the same <em>sequence</em>, but it will still look random across frames.</p>
</li>
</ul>
</li>
<li>
<p><strong>Other pitfalls that can make it appear unstable</strong></p>
<ul>
<li>
<p>If you ever call <code>randomSeed</code> again mid-sketch, you reset the generator and will repeat numbers.</p>
</li>
<li>
<p>Mixing <code>noise()</code> and <code>random()</code> without reseeding can give confusing results (different PRNG state).</p>
</li>
</ul>
</li>
</ol>

<h2>How to fix depending on your intention</h2>
<p>👉 <strong>If you want a <em>fixed</em> random position every frame (i.e. same number each draw):</strong></p>
<ul>
<li>
<p>Precompute the random values in <code>setup</code> and store them in an array or React state, then just read them in <code>draw</code>.</p>
</li>
</ul>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes">&lt;<span class="hljs-variable constant_">P5</span>.<span class="hljs-property">Setup</span> fn={<span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> {
  p5.<span class="hljs-title function_">randomSeed</span>(<span class="hljs-number">99</span>);
  <span class="hljs-keyword">const</span> xs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">20</span> }, <span class="hljs-function">() =&gt;</span> p5.<span class="hljs-title function_">random</span>(<span class="hljs-number">25</span>, <span class="hljs-number">175</span>));
  p5.<span class="hljs-property">_myRandomXs</span> = xs; <span class="hljs-comment">// attach to p5 instance</span>
}} /&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> {
  p5.background(200);
  p5._myRandomXs.forEach((x, i) =&gt; {
    p5.ellipse(x, 35 + 10 * p5.sin(p5.frameCount * 0.05), 50, 50);
  });
}} /&gt;</span>
</code></pre>

<p>👉 <strong>If you want the same <em>sequence</em> on every reload but changing each frame:</strong></p>
<p>Your code is already correct. Just expect each frame to be different, but restart → you’ll get the same sequence again. To verify, add:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p5.<span class="hljs-title function_">random</span>(<span class="hljs-number">25</span>, <span class="hljs-number">175</span>));
</code></pre>
<p>on frame 1 each reload — it should print the same number across reloads.</p>

<p>👉 <strong>If you want frame-stable randomness (same result every frame):</strong></p>
<p>Instead of <code>random()</code>, derive from a deterministic function like <code>noise()</code> or <code>sin()</code> that depends on <code>frameCount</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">let</span> x = p5.<span class="hljs-title function_">map</span>(p5.<span class="hljs-title function_">noise</span>(p5.<span class="hljs-property">frameCount</span> * <span class="hljs-number">0.01</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">25</span>, <span class="hljs-number">175</span>);
</code></pre>
<p>That way the “randomness” is reproducible from the frame index, not from a generator state.</p>

<p>✅ <strong>Summary:</strong></p>
<ul>
<li>
<p><code>randomSeed</code> makes the <em>sequence</em> reproducible, not the value constant across frames.</p>
</li>
<li>
<p>For constant randomness per object, precompute values once and reuse.</p>
</li>
<li>
<p>For deterministic pseudo-random motion, use <code>noise</code> or functions of <code>frameCount</code>.</p>
</li>
</ul>

<p>Do you want me to show you how to refactor your <code>Example</code> so that <strong>each of the <code>count</code> ellipses gets its own fixed random x-position</strong>, but they all animate vertically in sync (with <code>sin</code>)?</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">OK great. But noise is not what I'm trying to achieve; I want a random, stable position for each value of i, and the just change the y using sin to make a hover effect. What would be the best approach?
And also, can you tell me how we'd be using react state to keep track of the values (without fear of re-rendering the canvas DOM element on change)?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Great question. You want each dot’s <strong>x</strong> to be random but <strong>stable per index <code>i</code></strong>, while <strong>y</strong> gently hovers with <code>sin</code>. And you want to manage this with React state <strong>without remounting the canvas</strong>.</p>
<p>Two parts:</p>
<ol>
<li>
<p>how to generate stable “random” x’s</p>
</li>
<li>
<p>how to pass them through React state/props without recreating your <code>&lt;P5.Canvas&gt;</code></p>
</li>
</ol>

<h1>1) Stable random per index</h1>
<p>You have a few good options:</p>
<h3>Option A — Precompute once with a seeded PRNG (sequence-based)</h3>
<p>Generate the first <code>count</code> numbers from a seeded PRNG and reuse them forever:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// tiny deterministic PRNG</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">mulberry32</span>(<span class="hljs-params">seed</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> t = (seed += <span class="hljs-number">0x6D2B79F5</span>);
    t = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(t ^ (t &gt;&gt;&gt; <span class="hljs-number">15</span>), t | <span class="hljs-number">1</span>);
    t ^= t + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(t ^ (t &gt;&gt;&gt; <span class="hljs-number">7</span>), t | <span class="hljs-number">61</span>);
    <span class="hljs-keyword">return</span> ((t ^ (t &gt;&gt;&gt; <span class="hljs-number">14</span>)) &gt;&gt;&gt; <span class="hljs-number">0</span>) / <span class="hljs-number">4294967296</span>;
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">genXs</span>(<span class="hljs-params">seed, count, min=<span class="hljs-number">25</span>, max=<span class="hljs-number">175</span></span>) {
  <span class="hljs-keyword">const</span> rnd = <span class="hljs-title function_">mulberry32</span>(seed);
  <span class="hljs-keyword">const</span> xs = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: count }, <span class="hljs-function">() =&gt;</span> min + <span class="hljs-title function_">rnd</span>() * (max - min));
  <span class="hljs-keyword">return</span> xs;
}
</code></pre>
<p>Pros: simple.
Con: values depend on <strong>order/length</strong>; if you change the order of <code>i</code> or generate a different number of items, you must always regenerate from the same seed to keep the first <code>N</code> stable (usually fine).</p>
<h3>Option B — Per-index hash (index-based)</h3>
<p>Compute x from <strong>(seed, i)</strong> so each index is stable, independent of <code>count</code> growth/shifts:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// stable 0..1 value from (seed, i)</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">rand01FromIndex</span>(<span class="hljs-params">seed, i</span>) {
  <span class="hljs-comment">// mulberry32 seeded by seed ^ i</span>
  <span class="hljs-keyword">let</span> s = (seed ^ (i * <span class="hljs-number">0x9E3779B1</span>)) &gt;&gt;&gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mulberry32</span>(s)();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">xFromIndex</span>(<span class="hljs-params">seed, i, min=<span class="hljs-number">25</span>, max=<span class="hljs-number">175</span></span>) {
  <span class="hljs-keyword">return</span> min + <span class="hljs-title function_">rand01FromIndex</span>(seed, i) * (max - min);
}
</code></pre>
<p>Pros: adding/removing elements doesn’t change existing indices’ values.
Con: a tad more code, but very robust.</p>

<h1>2) Using React state/props without remounting the canvas</h1>
<p>In your P5 integration:</p>
<ul>
<li>
<p>Changing <strong><code>&lt;P5.Draw fn/params&gt;</code></strong> only <strong>hot-swaps</strong> the draw function; it does <strong>not</strong> recreate the canvas.</p>
</li>
<li>
<p>Changing <strong><code>&lt;P5.Setup&gt;</code></strong> props <strong>does</strong> trigger a full recreate (by design).</p>
</li>
</ul>
<p>So: <strong>keep <code>Setup</code> static</strong>, and pass your x-positions via <code>Draw</code>’s <code>params</code>. That way you can update React state freely without recreating the canvas.</p>
<h3>Example: sequence-based precompute with a “Reseed” button</h3>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useMemo, useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">mulberry32</span>(<span class="hljs-params">seed</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> t = (seed += <span class="hljs-number">0x6D2B79F5</span>);
    t = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(t ^ (t &gt;&gt;&gt; <span class="hljs-number">15</span>), t | <span class="hljs-number">1</span>);
    t ^= t + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(t ^ (t &gt;&gt;&gt; <span class="hljs-number">7</span>), t | <span class="hljs-number">61</span>);
    <span class="hljs-keyword">return</span> ((t ^ (t &gt;&gt;&gt; <span class="hljs-number">14</span>)) &gt;&gt;&gt; <span class="hljs-number">0</span>) / <span class="hljs-number">4294967296</span>;
  };
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">genXs</span>(<span class="hljs-params">seed, count, min=<span class="hljs-number">25</span>, max=<span class="hljs-number">175</span></span>) {
  <span class="hljs-keyword">const</span> rnd = <span class="hljs-title function_">mulberry32</span>(seed);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: count }, <span class="hljs-function">() =&gt;</span> min + <span class="hljs-title function_">rnd</span>() * (max - min));
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">{ count = <span class="hljs-number">10</span> }</span>) {
  <span class="hljs-keyword">const</span> [seed, setSeed] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">99</span>);

  <span class="hljs-comment">// Recompute xs whenever count or seed changes; memoized for perf/stability</span>
  <span class="hljs-keyword">const</span> xs = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">genXs</span>(seed, count, <span class="hljs-number">25</span>, <span class="hljs-number">175</span>), [seed, count]);

  <span class="hljs-keyword">const</span> onReseed = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setSeed</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> s + <span class="hljs-number">1</span>); <span class="hljs-comment">// any deterministic change</span>
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onReseed}</span>&gt;</span>Reseed<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
          {/* Keep Setup stable so canvas is not recreated */}
          <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> { p5.background(200); }} /&gt;

          {/* Pass xs via params — does NOT recreate canvas, just updates draw */}
          <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span>
            <span class="hljs-attr">params</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">xs</span> }}
            <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5,</span> { <span class="hljs-attr">xs</span> }) =&gt;</span> {
              p5.background(200);
              for (let i = 0; i &lt; xs.length; i++) {
                p5.ellipse(xs[i], 35 + 10 * p5.sin(p5.frameCount * 0.05), 50, 50);
              }
            }}
          /&gt;
        <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<p>If you prefer the <strong>index-based</strong> approach (stable per <code>i</code> regardless of <code>count</code> evolution), skip precomputing entirely and compute <code>x</code> in draw:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rand01FromIndex</span>(<span class="hljs-params">seed, i</span>) {
  <span class="hljs-keyword">let</span> s = (seed ^ (i * <span class="hljs-number">0x9E3779B1</span>)) &gt;&gt;&gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">mulberry32</span>(s)();
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">xFromIndex</span>(<span class="hljs-params">seed, i, min=<span class="hljs-number">25</span>, max=<span class="hljs-number">175</span></span>) {
  <span class="hljs-keyword">return</span> min + <span class="hljs-title function_">rand01FromIndex</span>(seed, i) * (max - min);
}

&lt;<span class="hljs-variable constant_">P5</span>.<span class="hljs-property">Draw</span>
  params={{ seed, count }}
  fn={<span class="hljs-function">(<span class="hljs-params">p5, { seed, count }</span>) =&gt;</span> {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">200</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
      <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">xFromIndex</span>(seed, i, <span class="hljs-number">25</span>, <span class="hljs-number">175</span>);
      p5.<span class="hljs-title function_">ellipse</span>(x, <span class="hljs-number">35</span> + <span class="hljs-number">10</span> * p5.<span class="hljs-title function_">sin</span>(p5.<span class="hljs-property">frameCount</span> * <span class="hljs-number">0.05</span>), <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
    }
  }}
/&gt;
</code></pre>
<p>Both versions keep React in charge of the data model, while your canvas stays mounted (no DOM churn). This fits your library’s contract:</p>
<ul>
<li>
<p><strong><code>Draw</code> changes</strong> → hot swap only (no recreate)</p>
</li>
<li>
<p><strong><code>Setup</code> changes</strong> → recreate (so keep it stable)</p>
</li>
</ul>
<p>If you want the x-positions to <strong>survive hot-reloads</strong> or other external changes, you can also cache them in a <code>useRef</code> or in a parent-level state/store (Zustand/Redux/etc.) and pass down via <code>params</code>—still no canvas remount as long as <code>Canvas</code> props and <code>Setup</code> are stable.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">I don't necessarily want the save values every time we refresh the page, only keep the same random value for a value of i across draw cycles. I guess that I could use useEffect to push a Math.random value when count differs from the length of an array of numbers?
Alt, is there a p5 way to do this?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’ve got two good patterns—pick the one that fits your style.</p>
<h1>A) React-side cache (session-stable, zero p5 tricks)</h1>
<p>Keep a session-local array of x’s that:</p>
<ul>
<li>
<p>grows when <code>count</code> grows (push new randoms),</p>
</li>
<li>
<p>shrinks when <code>count</code> shrinks (truncate),</p>
</li>
<li>
<p>stays constant across draw cycles.</p>
</li>
</ul>
<p>Use a <code>ref</code> (no extra rerenders) or <code>state</code> (fine too—your canvas won’t remount; <code>&lt;P5.Draw&gt;</code> hot-swaps only). Your lib was built for this: changing <code>&lt;P5.Draw&gt;</code> props/params updates the draw function without recreating the canvas, while changing <code>&lt;P5.Setup&gt;</code> would recreate it.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useEffect, useMemo, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">{ count = <span class="hljs-number">10</span>, min = <span class="hljs-number">25</span>, max = <span class="hljs-number">175</span> }</span>) {
  <span class="hljs-comment">// Use a ref to avoid extra rerenders; values persist within the session/page.</span>
  <span class="hljs-keyword">const</span> xsRef = <span class="hljs-title function_">useRef</span>([]);

  <span class="hljs-comment">// Keep xsRef.current length in sync with `count` (session-stable randoms)</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> xs = xsRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (xs.<span class="hljs-property">length</span> &lt; count) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = xs.<span class="hljs-property">length</span>; i &lt; count; i++) {
        xs.<span class="hljs-title function_">push</span>(min + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min));
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xs.<span class="hljs-property">length</span> &gt; count) {
      xs.<span class="hljs-property">length</span> = count;
    }
  }, [count, min, max]);

  <span class="hljs-comment">// If you want to force a new session pattern sometimes:</span>
  <span class="hljs-keyword">const</span> [bump, setBump] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">xs</span>: xsRef.<span class="hljs-property">current</span> }), [bump, count]);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> { xsRef.current = []; setBump(x =&gt; x + 1); }}&gt;
        New session pattern
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
          {/* Keep Setup stable so the canvas is NOT recreated */}
          <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> { p5.background(200); }} /&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span>
            <span class="hljs-attr">params</span>=<span class="hljs-string">{params}</span>
            <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5,</span> { <span class="hljs-attr">xs</span> }) =&gt;</span> {
              p5.background(200);
              for (let i = 0; i &lt; xs.length; i++) {
                const x = xs[i];
                const y = 35 + 10 * p5.sin(p5.frameCount * 0.05);
                p5.ellipse(x, y, 50, 50);
              }
            }}
          /&gt;
        <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<p>Why this works:</p>
<ul>
<li>
<p><code>xsRef</code> holds the randoms for the whole session.</p>
</li>
<li>
<p>When <code>count</code> changes, you only add/remove entries; existing indices keep their x.</p>
</li>
<li>
<p>Passing <code>params</code> to <code>&lt;P5.Draw&gt;</code> updates the draw loop without tearing down the canvas (by design).</p>
</li>
</ul>
<h1>B) Pure p5-way (deterministic per index, no stored array)</h1>
<p>If you’d rather not store anything, reseed per index in <code>draw</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE_SEED</span> = <span class="hljs-number">1234</span>;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span>
  <span class="hljs-attr">params</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">count:</span> <span class="hljs-attr">10</span>, <span class="hljs-attr">min:</span> <span class="hljs-attr">25</span>, <span class="hljs-attr">max:</span> <span class="hljs-attr">175</span> }}
  <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5,</span> { <span class="hljs-attr">count</span>, <span class="hljs-attr">min</span>, <span class="hljs-attr">max</span> }) =&gt;</span> {
    p5.background(200);
    for (let i = 0; i &lt; count; i++) {
      // Reseed for each i → same x for that i every frame in this session
      p5.randomSeed(BASE_SEED + i);
      const x = p5.random(min, max);

      const y = 35 + 10 * p5.sin(p5.frameCount * 0.05);
      p5.ellipse(x, y, 50, 50);
    }
  }}
/&gt;</span>
</code></pre>
<p>Pros:</p>
<ul>
<li>
<p>No React state/refs for x’s.</p>
</li>
<li>
<p>Each index gets a stable x each frame.</p>
</li>
</ul>
<p>Caveat:</p>
<ul>
<li>
<p>You’re resetting the RNG repeatedly. That’s fine if all your randomness follows this pattern. If you also need other randoms (e.g., particle effects), this approach will overwrite their RNG state—so either:</p>
<ul>
<li>
<p>confine those other randoms to their own reseeding scheme, or</p>
</li>
<li>
<p>prefer the React cache (Approach A) and keep p5’s RNG free for other uses.</p>
</li>
</ul>
</li>
</ul>
<h1>Which should you use?</h1>
<ul>
<li>
<p><strong>Most React-y:</strong> Approach A (cache in React with <code>ref</code>/<code>state</code>). Clean, fast, and doesn’t interfere with other random uses.</p>
</li>
<li>
<p><strong>p5-pure, no storage:</strong> Approach B (reseed per index). Great when you want deterministic per-index values without keeping arrays—just be mindful of RNG side effects.</p>
</li>
</ul>
<p>Either way, keep <code>&lt;P5.Setup&gt;</code> stable and flow your changing data via <code>&lt;P5.Draw params={...}&gt;</code> so the canvas stays mounted and smooth.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">It may be my memory about the behaviour of hooks, but if a useState is changed, doesn't that force all the children of the component where it is used to be rerendered?
</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’re remembering correctly — <strong>changing a <code>useState</code> value in a component does cause that component to rerender</strong>, and that means React will re-invoke its children too.</p>
<p>But there’s an important nuance for your <code>&lt;P5.Canvas&gt;</code>:</p>

<h3>🔑 How your <code>lib/p5</code> was designed</h3>
<ul>
<li>
<p><code>&lt;P5.Canvas&gt;</code> will <strong>only recreate the p5 instance</strong> if <em>its own props</em> (<code>id</code>, <code>width</code>, <code>height</code>, <code>renderer</code>, or <code>&lt;P5.Setup&gt;</code>) change.</p>
</li>
<li>
<p>If you change props on <code>&lt;P5.Draw&gt;</code>, the canvas <strong>stays mounted</strong>; the <code>draw</code> function is just swapped out live.</p>
</li>
<li>
<p>React rerendering doesn’t mean DOM remounting. React is very surgical: it’ll diff the JSX tree, notice that <code>&lt;P5.Canvas&gt;</code> is the same with the same props, and leave the DOM node (and the p5 instance inside it) untouched.</p>
</li>
</ul>

<h3>✅ Safe patterns</h3>
<p>So you can absolutely keep random values in <strong>React state</strong> or <strong>React refs</strong>:</p>
<ul>
<li>
<p>If you store them in <code>state</code> and pass down via <code>&lt;P5.Draw params={...}&gt;</code>:</p>
<ul>
<li>
<p>React will rerender → <code>&lt;P5.Draw&gt;</code> gets new props → your hook updates the draw function.</p>
</li>
<li>
<p><strong>Canvas DOM and p5 instance are unchanged.</strong></p>
</li>
</ul>
</li>
<li>
<p>If you store them in a <code>ref</code>:</p>
<ul>
<li>
<p>No rerender needed when the ref mutates, but you’ll usually wrap it with <code>useMemo</code>/<code>useEffect</code> to keep in sync with <code>count</code>.</p>
</li>
</ul>
</li>
</ul>

<h3>🚦 Rule of thumb</h3>
<ul>
<li>
<p><strong>useState</strong> → triggers rerender → fine, React diffs, p5 canvas persists.</p>
</li>
<li>
<p><strong>useRef</strong> → no rerender, manual reads/writes → also fine.</p>
</li>
</ul>
<p>Both are safe here. The only way you “lose” the canvas is if you change <code>&lt;P5.Setup&gt;</code> props or the canvas core props, because those intentionally cause recreate.</p>

<p>👉 So: don’t worry about React state “forcing a canvas remount.” With your library, state updates just cause React to <em>diff</em> the tree, not tear down p5.</p>
<p>Would you like me to give you a side-by-side example: one with <code>useState</code> and one with <code>useRef</code>, showing how they both keep stable randoms across frames?</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">How would I memoize the drawFn, cause it gets recreated every cycle no?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Great question. In your lib, <code>&lt;P5.Draw&gt;</code> rebinds <code>p5.draw</code> in a <code>useEffect</code> that depends on <strong><code>fn</code> and <code>params</code></strong>—so if either gets a new identity on render, it hot-swaps the draw loop. That’s fine (no canvas remount), but you can avoid unnecessary swaps.</p>
<p>You’ve got two solid patterns:</p>
<h1>Pattern A — Memoize function + params (typical React)</h1>
<ul>
<li>
<p>Wrap the draw function with <code>useCallback</code>.</p>
</li>
<li>
<p>Wrap the params object with <code>useMemo</code> (so you don’t recreate <code>{…}</code> inline every render).</p>
</li>
</ul>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useMemo, useCallback, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">{ xs }</span>) {
  <span class="hljs-comment">// memoize params object so identity is stable unless xs changes</span>
  <span class="hljs-keyword">const</span> drawParams = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ xs }), [xs]);

  <span class="hljs-comment">// memoize draw fn; include minimal dependencies to avoid stale closures</span>
  <span class="hljs-keyword">const</span> drawFn = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">p5, { xs }</span>) =&gt;</span> {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">200</span>);
    <span class="hljs-keyword">const</span> y = <span class="hljs-number">35</span> + <span class="hljs-number">10</span> * p5.<span class="hljs-title function_">sin</span>(p5.<span class="hljs-property">frameCount</span> * <span class="hljs-number">0.05</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; xs.<span class="hljs-property">length</span>; i++) p5.<span class="hljs-title function_">ellipse</span>(xs[i], y, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
  }, []); <span class="hljs-comment">// ok because it only reads from params</span>

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
        {/* Keep Setup stable to avoid full recreate */}
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> p5.background(200)} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{drawFn}</span> <span class="hljs-attr">params</span>=<span class="hljs-string">{drawParams}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<p>Result: <code>&lt;P5.Draw&gt;</code>’s effect only runs (and rebinds <code>p5.draw</code>) when <code>xs</code> actually changes, not every parent render. (Because in your implementation, the effect keys are <code>fn</code> and <code>params</code>, and <code>Setup</code> changes would recreate the canvas.)</p>
<h1>Pattern B — Keep <code>fn</code> <em>permanently stable</em>; read changing data via refs</h1>
<p>If you want <strong>zero</strong> rebinds even when data changes, keep <code>fn</code> identity fixed and read mutable data from a ref that you update in effects.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useEffect, useMemo, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">{ xs }</span>) {
  <span class="hljs-keyword">const</span> xsRef = <span class="hljs-title function_">useRef</span>(xs);

  <span class="hljs-comment">// keep ref in sync without changing function identity</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> { xsRef.<span class="hljs-property">current</span> = xs; }, [xs]);

  <span class="hljs-comment">// stable draw function forever</span>
  <span class="hljs-keyword">const</span> drawFn = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> xsSnap = xsRef.<span class="hljs-property">current</span>;
      p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">200</span>);
      <span class="hljs-keyword">const</span> y = <span class="hljs-number">35</span> + <span class="hljs-number">10</span> * p5.<span class="hljs-title function_">sin</span>(p5.<span class="hljs-property">frameCount</span> * <span class="hljs-number">0.05</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; xsSnap.<span class="hljs-property">length</span>; i++) p5.<span class="hljs-title function_">ellipse</span>(xsSnap[i], y, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
    };
  }, []); <span class="hljs-comment">// never changes</span>

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> p5.background(200)} /&gt;
        {/* params not needed since fn reads from ref */}
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{drawFn}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<p>Result: <code>fn</code> identity never changes → <code>&lt;P5.Draw&gt;</code> never calls <code>setDraw</code> again after mount, yet your animation uses the latest data via <code>xsRef.current</code>.</p>

<h2>When to use which?</h2>
<ul>
<li>
<p><strong>Pattern A</strong>: Most idiomatic; use when you’re happy to rebind <code>p5.draw</code> only when inputs truly change. Keep deps small and params memoized.</p>
</li>
<li>
<p><strong>Pattern B</strong>: Ultra-optimized; avoid <em>any</em> rebinds. Great for high-frequency parent rerenders or large trees.</p>
</li>
</ul>
<p>Both keep the canvas mounted; only <code>&lt;P5.Setup&gt;</code> or core canvas props can trigger a full recreate by design.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">Give me something to have random colors</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Got it 👍 You want each shape to have a <strong>stable color across frames</strong>, just like we did for positions. Same principles apply: pre-assign colors (React-side or per-index hash) and then animate with <code>sin</code> for hover.</p>

<h1>Option A — React precompute (session-stable randoms)</h1>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params">{ count = <span class="hljs-number">10</span> }</span>) {
  <span class="hljs-keyword">const</span> xsRef = <span class="hljs-title function_">useRef</span>([]);
  <span class="hljs-keyword">const</span> colorsRef = <span class="hljs-title function_">useRef</span>([]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Grow arrays if count increases</span>
    <span class="hljs-keyword">while</span> (xsRef.<span class="hljs-property">current</span>.<span class="hljs-property">length</span> &lt; count) {
      xsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">25</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">150</span>); <span class="hljs-comment">// x between 25..175</span>
      colorsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">push</span>([
        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">255</span>),
        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">255</span>),
        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">255</span>),
      ]);
    }
    <span class="hljs-comment">// Shrink arrays if count decreases</span>
    xsRef.<span class="hljs-property">current</span>.<span class="hljs-property">length</span> = count;
    colorsRef.<span class="hljs-property">current</span>.<span class="hljs-property">length</span> = count;
  }, [count]);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> p5.background(200)} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span>
          <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> {
            p5.background(200);
            const y = 35 + 10 * p5.sin(p5.frameCount * 0.05);
            for (let i = 0; i &lt; count; i++) {
              const [r, g, b] = colorsRef.current[i];
              p5.fill(r, g, b);
              p5.ellipse(xsRef.current[i], y, 50, 50);
            }
          }}
        /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<ul>
<li>
<p>Each circle gets a random RGB color at mount (stable across frames).</p>
</li>
<li>
<p>Adding/removing <code>count</code> expands/shrinks both arrays.</p>
</li>
<li>
<p>Colors are stored in <code>colorsRef</code> (no rerenders).</p>
</li>
</ul>

<h1>Option B — Deterministic per-index color (no storage)</h1>
<p>If you want a reproducible palette every run (stable per index, computed on the fly):</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hashColor</span>(<span class="hljs-params">seed, i</span>) {
  <span class="hljs-comment">// simple hash from seed+i → 0..255</span>
  <span class="hljs-keyword">const</span> h = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(seed * (i + <span class="hljs-number">1</span>)) * <span class="hljs-number">10000</span>) &gt;&gt;&gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> [h % <span class="hljs-number">256</span>, (h &gt;&gt; <span class="hljs-number">8</span>) % <span class="hljs-number">256</span>, (h &gt;&gt; <span class="hljs-number">16</span>) % <span class="hljs-number">256</span>];
}

&lt;<span class="hljs-variable constant_">P5</span>.<span class="hljs-property">Draw</span>
  params={{ <span class="hljs-attr">count</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">seed</span>: <span class="hljs-number">123</span> }}
  fn={<span class="hljs-function">(<span class="hljs-params">p5, { count, seed }</span>) =&gt;</span> {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">200</span>);
    <span class="hljs-keyword">const</span> y = <span class="hljs-number">35</span> + <span class="hljs-number">10</span> * p5.<span class="hljs-title function_">sin</span>(p5.<span class="hljs-property">frameCount</span> * <span class="hljs-number">0.05</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
      <span class="hljs-keyword">const</span> [r, g, b] = <span class="hljs-title function_">hashColor</span>(seed, i);
      p5.<span class="hljs-title function_">fill</span>(r, g, b);
      p5.<span class="hljs-title function_">ellipse</span>(<span class="hljs-number">25</span> + i * <span class="hljs-number">30</span>, y, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
    }
  }}
/&gt;
</code></pre>
<ul>
<li>
<p>Colors are pure functions of <code>(seed, i)</code> → same every run for same seed.</p>
</li>
<li>
<p>No arrays needed; adding more <code>count</code> just extends the sequence.</p>
</li>
</ul>

<p>👉 Question for you: do you want the colors to be <strong>session-random but stable until reload</strong> (Option A), or <strong>deterministic based on a seed</strong> so that you can guarantee reproducibility across reloads (Option B)?</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Can you give me a PR template that summarize the work we have done so far (creating our P5 wrapper, why we did it, and the fact we've built a little example to showcase how it works)?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Here’s a <strong>pull request template</strong> you can drop at <code>.github/pull_request_template.md</code>. It’s tailored to the P5 wrapper work we just completed, and structured like an industry-standard PR doc. You can reuse it for this PR and adapt for future ones.</p>

<pre class="overflow-visible!"><code class="whitespace-pre! language-markdown code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-section">## 📝 Summary</span>

This PR introduces a <span class="hljs-strong">**custom React wrapper for p5.js**</span> under <span class="hljs-code">`src/lib/p5`</span>.

<span class="hljs-bullet">-</span> Provides a declarative API (<span class="hljs-code">`&lt;P5.Canvas&gt;`</span>, <span class="hljs-code">`&lt;P5.Setup&gt;`</span>, <span class="hljs-code">`&lt;P5.Draw&gt;`</span>)
<span class="hljs-bullet">-</span> Supports <span class="hljs-strong">**hot-swapping draw functions**</span> (multi-scene workflows)
<span class="hljs-bullet">-</span> Allows <span class="hljs-strong">**multiple p5 instances**</span> via a global registry/context
<span class="hljs-bullet">-</span> Makes it possible to control sketches with <span class="hljs-strong">**React state, context, and events**</span>
<span class="hljs-bullet">-</span> Extends naturally to <span class="hljs-strong">**networked apps**</span> (REST, WebSocket, multiplayer)

Also includes:
<span class="hljs-bullet">-</span> A small example component (<span class="hljs-code">`Example`</span>) demonstrating stable random positions/colors with hover animation.
<span class="hljs-bullet">-</span> Full test coverage (unit + integration) with a <span class="hljs-strong">**p5 mock**</span> for Jest.

---

<span class="hljs-section">## 🔍 Rationale</span>

We chose to build this wrapper instead of using [<span class="hljs-string">`@p5-wrapper/react`</span>](<span class="hljs-link">https://github.com/p5-wrapper/react</span>) because we needed:

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Declarative API**</span> that feels native to React rather than imperative sketch functions
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Hot-swappable draw functions**</span> without tearing down the canvas
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Multiple independent canvases**</span> with unique IDs, usable within the same app
<span class="hljs-bullet">-</span> A way to <span class="hljs-strong">**bind React state directly**</span> to p5 parameters (for interactivity, multiplayer, caching)
<span class="hljs-bullet">-</span> Clear integration with React testing (mocked p5, lifecycle tested)

This architecture makes it easier to plug p5 sketches into <span class="hljs-strong">**production-grade React apps**</span> that already rely on React Query, caching, and real-time interactions.

---

<span class="hljs-section">## 🧩 Implementation Details</span>

<span class="hljs-bullet">-</span> <span class="hljs-code">`src/lib/p5/components/`</span>  
<span class="hljs-bullet">  -</span> <span class="hljs-code">`P5Canvas.jsx`</span> → wraps canvas lifecycle (setup/recreate/resizing)
<span class="hljs-bullet">  -</span> <span class="hljs-code">`P5Setup.jsx`</span> → declarative setup function
<span class="hljs-bullet">  -</span> <span class="hljs-code">`P5Draw.jsx`</span> → declarative draw function (hot-swappable)

<span class="hljs-bullet">-</span> <span class="hljs-code">`src/lib/p5/context/`</span>  
<span class="hljs-bullet">  -</span> <span class="hljs-code">`RegistryContext.jsx`</span> → global registry of canvases
<span class="hljs-bullet">  -</span> <span class="hljs-code">`CanvasContext.jsx`</span> → per-canvas context for setup/draw

<span class="hljs-bullet">-</span> <span class="hljs-code">`src/lib/p5/hooks/`</span>  
<span class="hljs-bullet">  -</span> <span class="hljs-code">`useP5(id)`</span> → hook for single canvas registry entry
<span class="hljs-bullet">  -</span> <span class="hljs-code">`useP5List()`</span> → hook for list of active canvas IDs

<span class="hljs-bullet">-</span> <span class="hljs-strong">**Testing**</span>  
<span class="hljs-bullet">  -</span> Jest mock for <span class="hljs-code">`p5`</span> under <span class="hljs-code">`tests/__mocks__/p5.js`</span> (avoids loading real p5 in test env)
<span class="hljs-bullet">  -</span> Integration tests for multi-canvas and resize behavior
<span class="hljs-bullet">  -</span> Unit tests for components, contexts, and hooks

---

<span class="hljs-section">## 🎨 Example</span>

<span class="hljs-code">```jsx
function Example({ count = 10 }) {
  return (
    &lt;P5.ContextProvider&gt;
      &lt;P5.Canvas id="demo" width={400} height={300}&gt;
        &lt;P5.Setup fn={(p5) =&gt; p5.background(200)} /&gt;
        &lt;P5.Draw fn={(p5) =&gt; {
          p5.background(200);
          for (let i = 0; i &lt; count; i++) {
            const x = 25 + i * 30;
            const y = 35 + 10 * p5.sin(p5.frameCount * 0.05);
            p5.fill(200, 100 + i * 10, 255 - i * 20);
            p5.ellipse(x, y, 50, 50);
          }
        }} /&gt;
      &lt;/P5.Canvas&gt;
    &lt;/P5.ContextProvider&gt;
  );
}
</span></code></pre>

<h2>⚠️ Limitations</h2>
<ul>
<li>
<p>SSR: sketches require DOM, so hydration must be guarded (<code>typeof window !== 'undefined'</code>)</p>
</li>
<li>
<p>Only the latest <code>&lt;P5.Draw&gt;</code> is active per canvas</p>
</li>
<li>
<p>Changing <code>&lt;P5.Setup&gt;</code> triggers full canvas recreate (by design)</p>
</li>
<li>
<p>Colors/positions currently session-stable, not persisted across reloads (future: seed-based option)</p>
</li>
</ul>

<h2>👥 Attribution</h2>
<ul>
<li>
<p><strong>Primary Architect:</strong> Philippe Hébert</p>
</li>
<li>
<p><strong>Primary Implementer:</strong> ChatGPT (OpenAI)</p>
</li>
<li>
<p>Conversation logs and design rationale are stored in:
<code>src/lib/p5/ATTRIBUTION/*.html</code></p>
</li>
</ul>

<h2>✅ Checklist</h2>
<ul class="contains-task-list">
<li class="task-list-item">
<p> Core components implemented</p>
</li>
<li class="task-list-item">
<p> Hooks exposed (<code>useP5</code>, <code>useP5List</code>)</p>
</li>
<li class="task-list-item">
<p> Tests passing with p5 mock</p>
</li>
<li class="task-list-item">
<p> Example component added</p>
</li>
<li class="task-list-item">
<p> Documentation (<code>README.md</code>) created</p>
</li>
</ul>
<pre class="overflow-visible!"><code class="whitespace-pre! code-block hljs language-yaml" style="display: block;" data-highlighted="yes">
<span class="hljs-meta">---
</span>
<span class="hljs-string">Would</span> <span class="hljs-string">you</span> <span class="hljs-string">like</span> <span class="hljs-string">me</span> <span class="hljs-string">to</span> <span class="hljs-string">also</span> <span class="hljs-string">draft</span> <span class="hljs-string">a</span> <span class="hljs-string">**short</span> <span class="hljs-string">commit</span> <span class="hljs-string">message**</span> <span class="hljs-string">that</span> <span class="hljs-string">goes</span> <span class="hljs-string">with</span> <span class="hljs-string">this</span> <span class="hljs-string">PR,</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">same</span> <span class="hljs-string">style</span> <span class="hljs-string">(imperative,</span> <span class="hljs-string">concise)?</span>
</code></pre></div>
        </div>
      
        <div class="message user-message">
          <div class="content">I need some help integrating p5 plugins;
I want to install p5.collide2d, but p5.collide2d expects the p5 class to be on the window object;

I tried modifying the only import of p5 in P5Canvas.jsx:

<code>import p5js from 'p5';</code>
to
<code>import p5js from '../p5';</code>

and add

<code>lib/p5/p5.js</code>

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-javascript"><span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">'p5'</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">'undefined'</span>) {
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span> = p5js;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> p5js;</code></pre>

and in the App.jsx, do

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-clean"><span class="hljs-keyword">import</span> { P5 } <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/p5'</span>;
<span class="hljs-comment">// register plugins</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'p5.collide2d'</span>;</code></pre>

but I get an obscure React error</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’re on the right track—<code>p5.collide2d</code> wants a <strong>global</strong> <code>window.p5</code> at the moment it executes. The “obscure React error” usually comes from loading the plugin in an environment where <code>window</code> or <code>p5</code> isn’t ready (SSR/tests) or from accidentally pulling in a second copy / ESM variant that runs during render.</p>
<p>Here’s a clean, production-friendly pattern that avoids SSR/test pitfalls and guarantees the plugin sees <code>window.p5</code>.</p>

<h1>1) Keep a single p5 entry that globals it</h1>
<p>Create <code>src/lib/p5/p5.js</code> (your wrapper) and <strong>only import this</strong> everywhere:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// src/lib/p5/p5.js</span>
<span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"p5"</span>;

<span class="hljs-comment">// Only in browser</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">"undefined"</span>) {
  <span class="hljs-comment">// Avoid reassigning on HMR</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span>) <span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span> = p5js;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> p5js;
</code></pre>
<p>Then, in <strong><code>P5Canvas.jsx</code></strong>, import from the wrapper (not directly from <code>"p5"</code>):</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">- import p5js from "p5";</span>
<span class="hljs-addition">+ import p5js from "../p5/p5";</span>
</code></pre>
<p>This preserves your existing behavior; the only change is the import source. (Everything else in your Canvas/Draw/Setup remains the same.)</p>

<h1>2) Load the plugin dynamically on the client (no SSR/tests)</h1>
<p>Instead of <code>import "p5.collide2d"</code> at the top of <code>App.jsx</code>, do a guarded, dynamic import in an effect. That ensures:</p>
<ul>
<li>
<p><code>window</code> exists,</p>
</li>
<li>
<p><code>window.p5</code> is already set,</p>
</li>
<li>
<p>Jest won’t try to parse the plugin file.</p>
</li>
</ul>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// App.jsx (or a top-level provider)</span>
<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> mounted = <span class="hljs-literal">true</span>;

    (<span class="hljs-title function_">async</span> () =&gt; {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">"undefined"</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// SSR guard</span>
      <span class="hljs-comment">// Ensure our p5 wrapper ran and set window.p5</span>
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"src/lib/p5/p5"</span>); 
      <span class="hljs-comment">// Now load the plugin; it will patch window.p5 / p5.prototype</span>
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"p5.collide2d"</span>);
      <span class="hljs-comment">// optional: sanity check</span>
      <span class="hljs-keyword">if</span> (mounted &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span> &amp;&amp; !<span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">collideRectCircle</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">"p5.collide2d did not patch p5 as expected."</span>);
      }
    })();

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { mounted = <span class="hljs-literal">false</span>; };
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      {/* ... your canvases ... */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<blockquote>
<p>If you prefer, extract that to <code>src/lib/p5/loadPlugins.js</code> and call <code>loadP5Plugins()</code> in <code>App</code>.</p>
</blockquote>

<h1>3) Use the plugin in your draw</h1>
<p>Once loaded, the plugin methods (e.g., <code>collideRectCircle</code>) are available on the p5 instance/prototype. Example:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes">&lt;<span class="hljs-variable constant_">P5</span>.<span class="hljs-property">Draw</span>
  fn={<span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> hit = p5.<span class="hljs-title function_">collideRectCircle</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">80</span>, <span class="hljs-number">30</span>);
    p5.<span class="hljs-title function_">fill</span>(hit ? <span class="hljs-string">"red"</span> : <span class="hljs-string">"white"</span>);
    p5.<span class="hljs-title function_">rect</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">50</span>);
    p5.<span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">80</span>, <span class="hljs-number">30</span>);
  }}
/&gt;
</code></pre>

<h1>4) Keep tests happy (stub the plugin)</h1>
<p>Add a mapper in <strong><code>jest.config.cjs</code></strong> so Jest never tries to parse <code>p5.collide2d</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...your existing config...</span>
  <span class="hljs-attr">moduleNameMapper</span>: {
    <span class="hljs-string">"^src/(.*)$"</span>: <span class="hljs-string">"&lt;rootDir&gt;/src/$1"</span>,
    <span class="hljs-string">"^p5$"</span>: <span class="hljs-string">"&lt;rootDir&gt;/tests/__mocks__/p5.js"</span>,
    <span class="hljs-string">"^p5\\.collide2d$"</span>: <span class="hljs-string">"&lt;rootDir&gt;/tests/__mocks__/p5.collide2d.js"</span>, <span class="hljs-comment">// 👈 stub</span>
  },
};
</code></pre>
<p>Create <code>tests/__mocks__/p5.collide2d.js</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// no-op stub; in runtime the real plugin patches p5.prototype</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {};
</code></pre>
<p>This preserves your fast, mock-based testing strategy.</p>

<h1>5) Common gotchas (and how this avoids them)</h1>
<ul>
<li>
<p><strong>SSR / Next.js / Vite SSR:</strong> top-level <code>import "p5.collide2d"</code> executes during SSR and blows up (no <code>window</code>).
→ Dynamic <code>import()</code> in <code>useEffect</code> avoids SSR entirely.</p>
</li>
<li>
<p><strong>Double p5 copies:</strong> importing <code>"p5"</code> in one place and your wrapper elsewhere can lead to two p5s; the plugin might patch one while your sketch uses another.
→ Always import p5 via your wrapper (<code>src/lib/p5/p5.js</code>). Single source of truth.</p>
</li>
<li>
<p><strong>ESM parsing in Jest:</strong> plugin or p5’s ESM build triggers “Cannot use import statement outside a module”.
→ You’re mocking <code>p5</code>, and now also stubbing <code>p5.collide2d</code>, so Jest never parses them.</p>
</li>
<li>
<p><strong>Load order:</strong> plugin must see <code>window.p5</code> when it executes.
→ Your wrapper sets <code>window.p5</code>; the effect then loads the plugin after that.</p>
</li>
</ul>

<p>If you still see a React error after this, paste the exact message and stack and I’ll pinpoint it. But in practice, the above pattern (wrapper + dynamic plugin load + jest stub) is the most reliable way to integrate <code>p5</code> plugins that expect a browser global while keeping SSR/tests stable.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">Nevermind, it was an error of mine, I had started trying an interface with P5.Plugin component, but it did not exist. The solution I had already worked2/2</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Ah gotcha — glad it was just that and your solution works. 🙌</p>
<p>Couple of quick, optional tweaks to keep things smooth long-term:</p>
<ul>
<li>
<p>Use a single p5 entry (your <code>src/lib/p5/p5.js</code>) everywhere so plugins patch the same instance.</p>
</li>
<li>
<p>If you ever add SSR (Next/Vite SSR), load plugins in <code>useEffect</code> via dynamic <code>import()</code> to avoid <code>window</code> issues.</p>
</li>
<li>
<p>Keep the Jest stub for plugins (e.g. map <code>^p5\.collide2d$</code> to a no-op file) so tests don’t parse browser-only code.</p>
</li>
<li>
<p>Toss a short “Plugin Integration” note in <code>src/lib/p5/README.md</code> for future you.</p>
</li>
</ul>
<p>If you want, I can add a tiny <code>loadPlugins()</code> helper you call once at app start that ensures <code>window.p5</code> exists, then imports any plugins you list.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">I have an issue where there are two canvas created for every P5.Canvas component.
Both have separate p5 instances.

Here's the code:

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-javascript"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Children</span>,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;
<span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"../p5"</span>;

<span class="hljs-comment">/**
 * &lt;P5.Canvas id width height renderer className style&gt;
 * Children should include &lt;P5.Setup/&gt; and/or &lt;P5.Draw/&gt;, but any children are allowed.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Canvas</span>(<span class="hljs-params">{
  id,
  width,
  height,
  renderer = <span class="hljs-string">"P2D"</span>,
  className,
  style,
  children,
}</span>) {
  <span class="hljs-keyword">const</span> hostDivRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// per-instance refs/state</span>
  <span class="hljs-keyword">const</span> p5Ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> canvasRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> preloadSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });
  <span class="hljs-keyword">const</span> setupSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });
  <span class="hljs-keyword">const</span> drawSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });

  <span class="hljs-keyword">const</span> [ready, setReady] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [instanceKey, setInstanceKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> { registerCanvas, updateCanvas, unregisterCanvas } =
    <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>) || {};

  <span class="hljs-keyword">if</span> (!registerCanvas) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; must be used inside &lt;P5.ContextProvider&gt;."</span>);
  }
  <span class="hljs-keyword">if</span> (!id) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">"&lt;P5.Canvas&gt; requires an 'id' prop for multi-instance support."</span>,
    );
  }

  <span class="hljs-keyword">const</span> recreate = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setInstanceKey</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> k + <span class="hljs-number">1</span>), []);

  <span class="hljs-keyword">const</span> setPreloadSpec = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">spec</span>) =&gt;</span> {
      preloadSpecRef.<span class="hljs-property">current</span> = spec || { <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> };
      <span class="hljs-comment">// Contract: setup changes trigger full recreation</span>
      <span class="hljs-title function_">recreate</span>();
    },
    [recreate],
  );
  <span class="hljs-keyword">const</span> setSetupSpec = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">spec</span>) =&gt;</span> {
      setupSpecRef.<span class="hljs-property">current</span> = spec || { <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> };
      <span class="hljs-comment">// Contract: setup changes trigger full recreation</span>
      <span class="hljs-title function_">recreate</span>();
    },
    [recreate],
  );

  <span class="hljs-keyword">const</span> setDraw = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">fn, params</span>) =&gt;</span> {
    drawSpecRef.<span class="hljs-property">current</span> = { fn, params };
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (inst) {
      <span class="hljs-keyword">if</span> (fn) {
        inst.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(inst, drawSpecRef.<span class="hljs-property">current</span>.<span class="hljs-property">params</span>);
        inst.<span class="hljs-title function_">loop</span>();
      } <span class="hljs-keyword">else</span> {
        inst.<span class="hljs-title function_">noLoop</span>();
        inst.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {};
      }
    }
  }, []);

  <span class="hljs-comment">// Register in global registry on mount; unregister on unmount</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">registerCanvas</span>(id, {
      p5Ref,
      canvasRef,
      <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">size</span>: { width, height },
      setDraw,
      setPreloadSpec,
      setSetupSpec,
      recreate,
    });
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">unregisterCanvas</span>(id);
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [id]);

  <span class="hljs-comment">// Keep size up to date in registry</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
  }, [id, width, height, updateCanvas]);

  <span class="hljs-comment">// Create/recreate p5 instance when instanceKey/size/renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> host = hostDivRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!host) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sketch</span> = (<span class="hljs-params">p5</span>) =&gt; {
      p5Ref.<span class="hljs-property">current</span> = p5;

      p5.<span class="hljs-property">setup</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> rendererConst = renderer === <span class="hljs-string">"WEBGL"</span> ? p5.<span class="hljs-property">WEBGL</span> : p5.<span class="hljs-property">P2D</span>;
        <span class="hljs-keyword">const</span> cnv = p5.<span class="hljs-title function_">createCanvas</span>(width, height, rendererConst);
        canvasRef.<span class="hljs-property">current</span> = cnv.<span class="hljs-property">elt</span>;

        <span class="hljs-comment">// run user setup</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: setupFn, <span class="hljs-attr">params</span>: sparams } = setupSpecRef.<span class="hljs-property">current</span> || {};
        <span class="hljs-keyword">if</span> (setupFn) <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">setupFn</span>(p5, sparams)).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);

        <span class="hljs-comment">// bind user draw</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: drawFn, <span class="hljs-attr">params</span>: dparams } = drawSpecRef.<span class="hljs-property">current</span> || {};
        <span class="hljs-keyword">if</span> (drawFn) {
          p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">drawFn</span>(p5, dparams);
          p5.<span class="hljs-title function_">loop</span>();
        } <span class="hljs-keyword">else</span> {
          p5.<span class="hljs-title function_">noLoop</span>();
          p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {};
        }

        <span class="hljs-title function_">setReady</span>(<span class="hljs-literal">true</span>);
        <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
      };
    };

    <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">p5js</span>(sketch, host);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setReady</span>(<span class="hljs-literal">false</span>);
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">try</span> {
        inst.<span class="hljs-title function_">remove</span>();
        <span class="hljs-comment">// eslint-disable-next-line no-unused-vars</span>
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-comment">// noop</span>
      }
      <span class="hljs-keyword">if</span> (p5Ref.<span class="hljs-property">current</span> === inst) p5Ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      canvasRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
    };
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [instanceKey, width, height, renderer]);

  <span class="hljs-comment">// By default, change in width/height/renderer =&gt; recreate</span>
  <span class="hljs-comment">// Handle resize / renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (
      inst &amp;&amp;
      (renderer === <span class="hljs-string">"WEBGL"</span> ? inst.<span class="hljs-property">WEBGL</span> : inst.<span class="hljs-property">P2D</span>) ===
        inst.<span class="hljs-property">_renderer</span>?.<span class="hljs-property">GL</span>?.<span class="hljs-property">RENDERER</span>
    ) {
      <span class="hljs-comment">// same renderer → resize only</span>
      inst.<span class="hljs-title function_">resizeCanvas</span>(width, height);
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// renderer changed → must recreate</span>
      <span class="hljs-title function_">recreate</span>();
    }
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [width, height, renderer]);

  <span class="hljs-keyword">const</span> canvasCtxValue = <span class="hljs-title function_">useMemo</span>(
    <span class="hljs-function">() =&gt;</span> ({ id, setPreloadSpec, setSetupSpec, setDraw, recreate }),
    [id, setPreloadSpec, setSetupSpec, setDraw, recreate],
  );

  <span class="hljs-comment">// Let children render (Setup/Draw will hook via CanvasCtx)</span>
  <span class="hljs-keyword">const</span> renderedChildren = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">map</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CanvasContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{canvasCtxValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{hostDivRef}</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
        <span class="hljs-attr">data-testid</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">p5-host-</span>${<span class="hljs-attr">id</span>}`}
        <span class="hljs-attr">suppressHydrationWarning</span>
      /&gt;</span>
      {renderedChildren}
    <span class="hljs-tag">&lt;/<span class="hljs-name">CanvasContext.Provider</span>&gt;</span></span>
  );
}</code></pre>

Can you suggest a fix?</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’re seeing two canvases because the <strong>resize/recreate effect runs before the first p5 instance is set</strong>, so it calls <code>recreate()</code> immediately and you end up instantiating twice. In dev, React’s Strict Mode can amplify this pattern.</p>
<h2>What’s happening</h2>
<ul>
<li>
<p>On mount, the <strong>create effect</strong> runs and schedules <code>new p5js(sketch, host)</code>.</p>
</li>
<li>
<p>The <strong>resize/renderer effect</strong> also runs. Since <code>p5Ref.current</code> is still <code>null</code> on that first pass, your code falls into the <code>else</code> branch and calls <code>recreate()</code>, incrementing <code>instanceKey</code> → <strong>second instantiation</strong>.</p>
</li>
<li>
<p>Depending on timing, the first instance’s cleanup happens <strong>after</strong> the second instance is created, so two canvases can coexist.</p>
</li>
</ul>
<h2>Fix (minimal + robust)</h2>
<ol>
<li>
<p><strong>Don’t recreate if there’s no current instance yet.</strong>
Early-return in the resize/renderer effect:</p>
</li>
</ol>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes">  useEffect(() =&gt; {
<span class="hljs-deletion">-   const inst = p5Ref.current;</span>
<span class="hljs-deletion">-   if (</span>
<span class="hljs-deletion">-     inst &amp;&amp;</span>
<span class="hljs-deletion">-     (renderer === "WEBGL" ? inst.WEBGL : inst.P2D) ===</span>
<span class="hljs-deletion">-       inst._renderer?.GL?.RENDERER</span>
<span class="hljs-deletion">-   ) {</span>
<span class="hljs-addition">+   const inst = p5Ref.current;</span>
<span class="hljs-addition">+   // If no instance yet, do nothing. Creation effect will handle it.</span>
<span class="hljs-addition">+   if (!inst) return;</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+   if (</span>
<span class="hljs-addition">+     (renderer === "WEBGL" ? inst.WEBGL : inst.P2D) ===</span>
<span class="hljs-addition">+     inst._renderer?.GL?.RENDERER</span>
<span class="hljs-addition">+   ) {</span>
      // same renderer → resize only
      inst.resizeCanvas(width, height);
      updateCanvas(id, { size: { width, height } });
    } else {
      // renderer changed → must recreate
      recreate();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [width, height, renderer]);
</code></pre>
<ol>
<li>
<p><strong>Clear the host before creating a new instance.</strong>
(Covers StrictMode double-mount and any plugin that left nodes around.)</p>
</li>
</ol>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes">  useEffect(() =&gt; {
    const host = hostDivRef.current;
    if (!host) return;
<span class="hljs-addition">+   // Ensure no stale canvases/wrappers are left in the host</span>
<span class="hljs-addition">+   while (host.firstChild) host.removeChild(host.firstChild);</span>

    const sketch = (p5) =&gt; {
      p5Ref.current = p5;
      p5.setup = () =&gt; {
        const rendererConst = renderer <span class="hljs-comment">=== "WEBGL" ? p5.WEBGL : p5.P2D;</span>
        const cnv = p5.createCanvas(width, height, rendererConst);
        canvasRef.current = cnv.elt;
        // ...
      };
    };

    const inst = new p5js(sketch, host);

    return () =&gt; {
      setReady(false);
      updateCanvas(id, { ready: false });
      try { inst.remove(); } catch (_) {}
      if (p5Ref.current <span class="hljs-comment">=== inst) p5Ref.current = null;</span>
      canvasRef.current = null;
<span class="hljs-addition">+     // Defensive: also clear any nodes the instance left behind</span>
<span class="hljs-addition">+     while (host.firstChild) host.removeChild(host.firstChild);</span>
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [instanceKey, width, height, renderer]);
</code></pre>
<ol>
<li>
<p>(Optional) <strong>Use <code>useLayoutEffect</code> for creation</strong> to avoid a paint in between teardown/recreate (purely for flicker polish).</p>
</li>
</ol>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">-import { ... , useEffect, ... } from "react";</span>
<span class="hljs-addition">+import { ... , useEffect, useLayoutEffect, ... } from "react";</span>

<span class="hljs-deletion">- useEffect(() =&gt; { /* create/remove p5 instance */ }, [instanceKey, width, height, renderer]);</span>
<span class="hljs-addition">+ useLayoutEffect(() =&gt; { /* create/remove p5 instance */ }, [instanceKey, width, height, renderer]);</span>
</code></pre>
<ol>
<li>
<p>(Optional) <strong>Guard StrictMode double-invoke</strong> even more with a local “creating” flag:</p>
</li>
</ol>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> creatingRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>);

<span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> host = hostDivRef.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">if</span> (!host || creatingRef.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;
  creatingRef.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);
  <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">p5js</span>(sketch, host);

  creatingRef.<span class="hljs-property">current</span> = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> { inst.<span class="hljs-title function_">remove</span>(); } <span class="hljs-keyword">catch</span> {}
    <span class="hljs-keyword">if</span> (p5Ref.<span class="hljs-property">current</span> === inst) p5Ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
    canvasRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);
  };
}, [instanceKey, width, height, renderer]);
</code></pre>
<h2>Why this fixes it</h2>
<ul>
<li>
<p>The resize/renderer effect <strong>no longer calls <code>recreate()</code> before the first instance exists</strong>, preventing the “double create” race.</p>
</li>
<li>
<p>Clearing the host ensures <strong>no orphaned canvas</strong> survives between instances (including with StrictMode’s mount–unmount–remount checks).</p>
</li>
<li>
<p>Using <code>useLayoutEffect</code> eliminates flicker during recreate cycles.</p>
</li>
</ul>
<p>If you still see doubles after this, ping me with a screenshot/console log—we can also log each <code>new p5js</code> and <code>inst.remove()</code> with the <code>id</code> to trace lifetimes.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">OK, I still have an issue:

Currently the recreate method is called multiple times per canvas, causing loaded assets (fonts, shaders, etc) to reset and create errors.

Here's the current implementation:

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-javascript"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Children</span>,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;
<span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"../p5"</span>;

<span class="hljs-comment">/**
 * &lt;P5.Canvas id width height renderer className style&gt;
 * Children should include &lt;P5.Setup/&gt; and/or &lt;P5.Draw/&gt;, but any children are allowed.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Canvas</span>(<span class="hljs-params">{
  id,
  width,
  height,
  renderer = <span class="hljs-string">"P2D"</span>,
  className,
  style,
  children,
}</span>) {
  <span class="hljs-keyword">const</span> hostDivRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// per-instance refs/state</span>
  <span class="hljs-keyword">const</span> p5Ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> canvasRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> preloadSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });
  <span class="hljs-keyword">const</span> setupSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });
  <span class="hljs-keyword">const</span> drawSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });

  <span class="hljs-keyword">const</span> [ready, setReady] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [instanceKey, setInstanceKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> { registerCanvas, updateCanvas, unregisterCanvas } =
    <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>) || {};

  <span class="hljs-keyword">if</span> (!registerCanvas) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; must be used inside &lt;P5.ContextProvider&gt;."</span>);
  }
  <span class="hljs-keyword">if</span> (!id) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">"&lt;P5.Canvas&gt; requires an 'id' prop for multi-instance support."</span>,
    );
  }

  <span class="hljs-keyword">const</span> recreate = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[P5.Canvas] recreate"</span>);
    <span class="hljs-title function_">setInstanceKey</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> k + <span class="hljs-number">1</span>);
  }, []);

  <span class="hljs-keyword">const</span> setPreloadSpec = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">spec</span>) =&gt;</span> {
      preloadSpecRef.<span class="hljs-property">current</span> = spec || { <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> };
      <span class="hljs-comment">// Contract: setup changes trigger full recreation</span>
      <span class="hljs-title function_">recreate</span>();
    },
    [recreate],
  );
  <span class="hljs-keyword">const</span> setSetupSpec = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">spec</span>) =&gt;</span> {
      setupSpecRef.<span class="hljs-property">current</span> = spec || { <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> };
      <span class="hljs-comment">// Contract: setup changes trigger full recreation</span>
      <span class="hljs-title function_">recreate</span>();
    },
    [recreate],
  );

  <span class="hljs-keyword">const</span> setDraw = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">fn, params</span>) =&gt;</span> {
    drawSpecRef.<span class="hljs-property">current</span> = { fn, params };
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (inst) {
      <span class="hljs-keyword">if</span> (fn) {
        inst.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(inst, drawSpecRef.<span class="hljs-property">current</span>.<span class="hljs-property">params</span>);
        inst.<span class="hljs-title function_">loop</span>();
      } <span class="hljs-keyword">else</span> {
        inst.<span class="hljs-title function_">noLoop</span>();
        inst.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {};
      }
    }
  }, []);

  <span class="hljs-comment">// Register in global registry on mount; unregister on unmount</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">registerCanvas</span>(id, {
      p5Ref,
      canvasRef,
      <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">size</span>: { width, height },
      setDraw,
      setPreloadSpec,
      setSetupSpec,
      recreate,
    });
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">unregisterCanvas</span>(id);
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [id]);

  <span class="hljs-comment">// Keep size up to date in registry</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
  }, [id, width, height, updateCanvas]);

  <span class="hljs-comment">// Create/recreate p5 instance when instanceKey/size/renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> host = hostDivRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!host) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// Ensure no stale canvases/wrappers are left in the host</span>
    <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sketch</span> = (<span class="hljs-params">p5</span>) =&gt; {
      p5Ref.<span class="hljs-property">current</span> = p5;

      p5.<span class="hljs-property">setup</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> rendererConst = renderer === <span class="hljs-string">"WEBGL"</span> ? p5.<span class="hljs-property">WEBGL</span> : p5.<span class="hljs-property">P2D</span>;
        <span class="hljs-keyword">const</span> cnv = p5.<span class="hljs-title function_">createCanvas</span>(width, height, rendererConst);
        canvasRef.<span class="hljs-property">current</span> = cnv.<span class="hljs-property">elt</span>;

        <span class="hljs-comment">// run user setup</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: setupFn, <span class="hljs-attr">params</span>: sparams } = setupSpecRef.<span class="hljs-property">current</span> || {};
        <span class="hljs-keyword">if</span> (setupFn) <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">setupFn</span>(p5, sparams)).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);

        <span class="hljs-comment">// bind user draw</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: drawFn, <span class="hljs-attr">params</span>: dparams } = drawSpecRef.<span class="hljs-property">current</span> || {};
        <span class="hljs-keyword">if</span> (drawFn) {
          p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">drawFn</span>(p5, dparams);
          p5.<span class="hljs-title function_">loop</span>();
        } <span class="hljs-keyword">else</span> {
          p5.<span class="hljs-title function_">noLoop</span>();
          p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {};
        }

        <span class="hljs-title function_">setReady</span>(<span class="hljs-literal">true</span>);
        <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
      };
    };

    <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">p5js</span>(sketch, host);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setReady</span>(<span class="hljs-literal">false</span>);
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">try</span> {
        inst.<span class="hljs-title function_">remove</span>();
        <span class="hljs-comment">// eslint-disable-next-line no-unused-vars</span>
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-comment">// noop</span>
      }
      <span class="hljs-keyword">if</span> (p5Ref.<span class="hljs-property">current</span> === inst) p5Ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      canvasRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
    };
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [instanceKey, width, height, renderer]);

  <span class="hljs-comment">// By default, change in width/height/renderer =&gt; recreate</span>
  <span class="hljs-comment">// Handle resize / renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-comment">// If no instance yet, do nothing. Creation effect will handle it.</span>
    <span class="hljs-keyword">if</span> (!inst) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (
      (renderer === <span class="hljs-string">"WEBGL"</span> ? inst.<span class="hljs-property">WEBGL</span> : inst.<span class="hljs-property">P2D</span>) ===
      inst.<span class="hljs-property">_renderer</span>?.<span class="hljs-property">GL</span>?.<span class="hljs-property">RENDERER</span>
    ) {
      <span class="hljs-comment">// same renderer → resize only</span>
      inst.<span class="hljs-title function_">resizeCanvas</span>(width, height);
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// renderer changed → must recreate</span>
      <span class="hljs-title function_">recreate</span>();
    }
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [width, height, renderer]);

  <span class="hljs-keyword">const</span> canvasCtxValue = <span class="hljs-title function_">useMemo</span>(
    <span class="hljs-function">() =&gt;</span> ({ id, setPreloadSpec, setSetupSpec, setDraw, recreate }),
    [id, setPreloadSpec, setSetupSpec, setDraw, recreate],
  );

  <span class="hljs-comment">// Let children render (Setup/Draw will hook via CanvasCtx)</span>
  <span class="hljs-keyword">const</span> renderedChildren = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">map</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CanvasContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{canvasCtxValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{hostDivRef}</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
        <span class="hljs-attr">data-testid</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">p5-host-</span>${<span class="hljs-attr">id</span>}`}
        <span class="hljs-attr">suppressHydrationWarning</span>
      /&gt;</span>
      {renderedChildren}
    <span class="hljs-tag">&lt;/<span class="hljs-name">CanvasContext.Provider</span>&gt;</span></span>
  );
}</code></pre>

Can you update the logic so that recreate is not called when a setup/preload function are created for the first time? I'd suggest you also late create the p5 object until all the rendered children have been rendered (because P5.Setup and P5.Preload set the setup and preload function).
</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>You’re right on both counts:</p>
<ol>
<li>
<p>we should NOT call <code>recreate()</code> during the initial wiring of <code>&lt;P5.Preload&gt;</code> / <code>&lt;P5.Setup&gt;</code>, and</p>
</li>
<li>
<p>we should only instantiate p5 <strong>after</strong> children have had a chance to register their specs.</p>
</li>
</ol>
<p>Below is a drop-in update that adds a <strong>boot barrier</strong> and <strong>conditional recreate</strong> logic.</p>

<h1>What changes</h1>
<ul>
<li>
<p><strong>Boot barrier (<code>bootReady</code>)</strong>: We delay the very first <code>new p5js(...)</code> until <em>after</em> one render tick, so children’s effects (<code>&lt;P5.Preload&gt;</code>/<code>&lt;P5.Setup&gt;</code>) have run and set their specs.
Implementation: a <code>useEffect(() =&gt; setBootReady(true), [])</code> and we make the create effect depend on <code>bootReady</code>.</p>
</li>
<li>
<p><strong>Recreate only after first instance</strong>: <code>setPreloadSpec</code> and <code>setSetupSpec</code> <strong>do not</strong> call <code>recreate()</code> before the first instance is created. After first instance exists, changes still trigger full recreate (contract preserved).</p>
</li>
<li>
<p><strong>Resize/renderer effect</strong>: It already early-returns when <code>!p5Ref.current</code>. That avoids a premature recreate on the initial mount.</p>
</li>
<li>
<p><strong>(Optional but helpful) Clear host DOM</strong>: Keep the host clean before/after instance creation to avoid orphans (esp. with StrictMode).</p>
</li>
</ul>
<p>You don’t need to change your <code>&lt;P5.Draw&gt;</code> logic—hot-swap still works as before, and <code>&lt;P5.Setup&gt;</code> still implies recreate <em>after the first instance exists</em>.</p>

<h1>Patched component</h1>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Children</span>,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;
<span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"../p5"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Canvas</span>(<span class="hljs-params">{
  id,
  width,
  height,
  renderer = <span class="hljs-string">"P2D"</span>,
  className,
  style,
  children,
}</span>) {
  <span class="hljs-keyword">const</span> hostDivRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// per-instance refs/state</span>
  <span class="hljs-keyword">const</span> p5Ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> canvasRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> preloadSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });
  <span class="hljs-keyword">const</span> setupSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });
  <span class="hljs-keyword">const</span> drawSpecRef = <span class="hljs-title function_">useRef</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> });

  <span class="hljs-comment">// boot + lifecycle flags</span>
  <span class="hljs-keyword">const</span> [bootReady, setBootReady] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// gate first creation until after children effects</span>
  <span class="hljs-keyword">const</span> [instanceKey, setInstanceKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> hasInstanceRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// becomes true after the first successful create</span>

  <span class="hljs-keyword">const</span> { registerCanvas, updateCanvas, unregisterCanvas } =
    <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>) || {};

  <span class="hljs-keyword">if</span> (!registerCanvas) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; must be used inside &lt;P5.ContextProvider&gt;."</span>);
  }
  <span class="hljs-keyword">if</span> (!id) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; requires an 'id' prop for multi-instance support."</span>);
  }

  <span class="hljs-comment">// Boot barrier: allow children (Preload/Setup) to run their useEffect first</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setBootReady</span>(<span class="hljs-literal">true</span>);
  }, []);

  <span class="hljs-keyword">const</span> recreate = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Only recreate after an instance has actually been created</span>
    <span class="hljs-keyword">if</span> (hasInstanceRef.<span class="hljs-property">current</span>) {
      <span class="hljs-comment">// console.log("[P5.Canvas] recreate");</span>
      <span class="hljs-title function_">setInstanceKey</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> k + <span class="hljs-number">1</span>);
    }
  }, []);

  <span class="hljs-keyword">const</span> setPreloadSpec = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">spec</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> prev = preloadSpecRef.<span class="hljs-property">current</span>;
      preloadSpecRef.<span class="hljs-property">current</span> = spec || { <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> };

      <span class="hljs-comment">// Do NOT recreate during boot (first-time wiring).</span>
      <span class="hljs-comment">// After first instance exists, changing preload requires full recreate.</span>
      <span class="hljs-keyword">const</span> isInitialSet =
        !hasInstanceRef.<span class="hljs-property">current</span> &amp;&amp; !prev?.<span class="hljs-property">fn</span> &amp;&amp; !!preloadSpecRef.<span class="hljs-property">current</span>.<span class="hljs-property">fn</span>;
      <span class="hljs-keyword">if</span> (!isInitialSet &amp;&amp; hasInstanceRef.<span class="hljs-property">current</span>) {
        <span class="hljs-title function_">recreate</span>();
      }
    },
    [recreate]
  );

  <span class="hljs-keyword">const</span> setSetupSpec = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">spec</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> prev = setupSpecRef.<span class="hljs-property">current</span>;
      setupSpecRef.<span class="hljs-property">current</span> = spec || { <span class="hljs-attr">fn</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">params</span>: <span class="hljs-literal">undefined</span> };

      <span class="hljs-comment">// Do NOT recreate during boot (first-time wiring).</span>
      <span class="hljs-comment">// After first instance exists, changing setup requires full recreate.</span>
      <span class="hljs-keyword">const</span> isInitialSet =
        !hasInstanceRef.<span class="hljs-property">current</span> &amp;&amp; !prev?.<span class="hljs-property">fn</span> &amp;&amp; !!setupSpecRef.<span class="hljs-property">current</span>.<span class="hljs-property">fn</span>;
      <span class="hljs-keyword">if</span> (!isInitialSet &amp;&amp; hasInstanceRef.<span class="hljs-property">current</span>) {
        <span class="hljs-title function_">recreate</span>();
      }
    },
    [recreate]
  );

  <span class="hljs-keyword">const</span> setDraw = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">fn, params</span>) =&gt;</span> {
    drawSpecRef.<span class="hljs-property">current</span> = { fn, params };
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (inst) {
      <span class="hljs-keyword">if</span> (fn) {
        inst.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(inst, drawSpecRef.<span class="hljs-property">current</span>.<span class="hljs-property">params</span>);
        inst.<span class="hljs-title function_">loop</span>();
      } <span class="hljs-keyword">else</span> {
        inst.<span class="hljs-title function_">noLoop</span>();
        inst.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {};
      }
    }
  }, []);

  <span class="hljs-comment">// registry lifecycle</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">registerCanvas</span>(id, {
      p5Ref,
      canvasRef,
      <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">size</span>: { width, height },
      setDraw,
      setPreloadSpec,
      setSetupSpec,
      recreate,
    });
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">unregisterCanvas</span>(id);
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [id]);

  <span class="hljs-comment">// keep size up to date</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
  }, [id, width, height, updateCanvas]);

  <span class="hljs-comment">// Create/recreate p5 instance (gated by bootReady)</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!bootReady) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// wait for one tick so children can set specs</span>

    <span class="hljs-keyword">const</span> host = hostDivRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!host) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// Ensure no stale nodes are left (StrictMode / plugin side-effects)</span>
    <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sketch</span> = (<span class="hljs-params">p5</span>) =&gt; {
      p5Ref.<span class="hljs-property">current</span> = p5;

      <span class="hljs-comment">// optional: support user preload if provided</span>
      <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: preloadFn, <span class="hljs-attr">params</span>: plParams } = preloadSpecRef.<span class="hljs-property">current</span> || {};
      <span class="hljs-keyword">if</span> (preloadFn) {
        p5.<span class="hljs-property">preload</span> = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">preloadFn</span>(p5, plParams);
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);
          }
        };
      }

      p5.<span class="hljs-property">setup</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> rendererConst = renderer === <span class="hljs-string">"WEBGL"</span> ? p5.<span class="hljs-property">WEBGL</span> : p5.<span class="hljs-property">P2D</span>;
        <span class="hljs-keyword">const</span> cnv = p5.<span class="hljs-title function_">createCanvas</span>(width, height, rendererConst);
        canvasRef.<span class="hljs-property">current</span> = cnv.<span class="hljs-property">elt</span>;

        <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: setupFn, <span class="hljs-attr">params</span>: sparams } = setupSpecRef.<span class="hljs-property">current</span> || {};
        <span class="hljs-keyword">if</span> (setupFn) <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">setupFn</span>(p5, sparams)).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);

        <span class="hljs-keyword">const</span> { <span class="hljs-attr">fn</span>: drawFn, <span class="hljs-attr">params</span>: dparams } = drawSpecRef.<span class="hljs-property">current</span> || {};
        <span class="hljs-keyword">if</span> (drawFn) {
          p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">drawFn</span>(p5, dparams);
          p5.<span class="hljs-title function_">loop</span>();
        } <span class="hljs-keyword">else</span> {
          p5.<span class="hljs-title function_">noLoop</span>();
          p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {};
        }

        hasInstanceRef.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// mark that we have created at least once</span>
        <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
      };
    };

    <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">p5js</span>(sketch, host);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">try</span> {
        inst.<span class="hljs-title function_">remove</span>();
      } <span class="hljs-keyword">catch</span> {}
      <span class="hljs-keyword">if</span> (p5Ref.<span class="hljs-property">current</span> === inst) p5Ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      canvasRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;

      <span class="hljs-comment">// Defensive clean</span>
      <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);
    };
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [bootReady, instanceKey, width, height, renderer]);

  <span class="hljs-comment">// Resize vs renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!inst) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// don’t trigger recreate during boot</span>

    <span class="hljs-keyword">const</span> currentRenderer = inst.<span class="hljs-property">_renderer</span>?.<span class="hljs-property">GL</span>?.<span class="hljs-property">RENDERER</span>;
    <span class="hljs-keyword">const</span> desired = renderer === <span class="hljs-string">"WEBGL"</span> ? inst.<span class="hljs-property">WEBGL</span> : inst.<span class="hljs-property">P2D</span>;

    <span class="hljs-keyword">if</span> (currentRenderer === desired) {
      inst.<span class="hljs-title function_">resizeCanvas</span>(width, height);
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">recreate</span>();
    }
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [width, height, renderer]);

  <span class="hljs-keyword">const</span> canvasCtxValue = <span class="hljs-title function_">useMemo</span>(
    <span class="hljs-function">() =&gt;</span> ({ id, setPreloadSpec, setSetupSpec, setDraw, recreate }),
    [id, setPreloadSpec, setSetupSpec, setDraw, recreate]
  );

  <span class="hljs-keyword">const</span> renderedChildren = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">map</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CanvasContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{canvasCtxValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{hostDivRef}</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
        <span class="hljs-attr">data-testid</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">p5-host-</span>${<span class="hljs-attr">id</span>}`}
        <span class="hljs-attr">suppressHydrationWarning</span>
      /&gt;</span>
      {renderedChildren}
    <span class="hljs-tag">&lt;/<span class="hljs-name">CanvasContext.Provider</span>&gt;</span></span>
  );
}
</code></pre>

<h2>Why this solves your asset resets</h2>
<ul>
<li>
<p>During the very first mount, <code>&lt;P5.Preload&gt;</code> / <code>&lt;P5.Setup&gt;</code> register their callbacks <strong>without</strong> triggering a recreate. Only after <code>bootReady</code> flips true do we create the p5 instance <strong>once</strong>, with both specs already in place → your assets (fonts, shaders, images) are loaded correctly in <code>preload</code> / <code>setup</code>, not reset mid-boot.</p>
</li>
<li>
<p>Later, if you <strong>change</strong> <code>&lt;P5.Setup&gt;</code> or <code>&lt;P5.Preload&gt;</code> (post-boot), we do call <code>recreate()</code>—which is the expected behavior for those contracts.</p>
</li>
</ul>
<p>If you want me to also add a tiny “debounce” for multiple spec changes in the same tick (to coalesce multiple <code>recreate()</code> calls into one), I can layer that in—but with the <code>hasInstanceRef</code> + boot barrier, you should already see the redundant recreates disappear.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">I have a feature request: I need to be able to set multiple callback on cursor events, but p5 only supports adding a single function to the event. I find that limiting, and I would like to know how you would suggest to approach this. 

I was thinking that the best approach would be to allow to expose an addEventListener function (or similarly named) via the context hooks, and have a state (useRef) inside the Canvas component that stores the listed events and event listener functions. The only thing I'm not clear about would be how to unregister the event listeners, since I think it would be impractical to keep track of the subscribed function refs directly. I think a better way would be to have a Map&lt;string, Map&lt;string, function&gt;&gt; where the first string is the event name, and the second string is user-managed id, which can then be removed using a removeEventListener function.

What do you think? </div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Love this feature—p5’s single-callback model on instance events (e.g., <code>mouseMoved</code>, <code>mousePressed</code>, <code>keyPressed</code>, <code>touchStarted</code>, etc.) is limiting. Your idea (an internal registry + public <code>addEventListener/removeEventListener</code>) is exactly how I’d do it.</p>
<p>Below is a concrete, production-ready approach that:</p>
<ul>
<li>
<p>Lets <strong>multiple listeners</strong> subscribe to the same p5 event.</p>
</li>
<li>
<p>Returns a <strong>convenient unsubscribe</strong> function.</p>
</li>
<li>
<p>Keeps listeners <strong>stable across re-creates</strong> (they live in React refs on the Canvas component).</p>
</li>
<li>
<p>Works with your existing context/hook pattern (similar to how <code>setDraw</code> is exposed).</p>
</li>
</ul>

<h1>API (what you’ll expose)</h1>
<p>From <code>CanvasContext</code> (and thus available through your <code>useP5(id)</code> / registry):</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-ts code-block hljs language-typescript" style="display: block;" data-highlighted="yes"><span class="hljs-title function_">addEventListener</span>(eventName, handler, opts?): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>
<span class="hljs-title function_">removeEventListener</span>(eventName, id): <span class="hljs-built_in">void</span>
</code></pre>
<ul>
<li>
<p><code>eventName</code>: one of p5’s instance event names (see list below).</p>
</li>
<li>
<p><code>handler</code>: <code>(p5, domEventOrWheelDelta) =&gt; any</code> — we pass the instance + raw event.</p>
</li>
<li>
<p><code>opts</code> (optional): <code>{ id?: string }</code> — if omitted, we auto-generate an ID.
The function returns an <strong>unsubscribe</strong> closure; you (usually) won’t need to track the ID yourself.</p>
</li>
</ul>
<p>Supported events (typical):
<code>"mouseMoved" | "mousePressed" | "mouseDragged" | "mouseReleased" | "mouseWheel" | "doubleClicked" | "keyPressed" | "keyReleased" | "keyTyped" | "touchStarted" | "touchMoved" | "touchEnded"</code></p>

<h1>Implementation (patches to <code>Canvas</code>)</h1>
<h2>1) Add a listeners registry + helpers</h2>
<p>Inside your <code>Canvas</code> component:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-addition">+ // Multi-listener registry: Map&lt;eventName, Map&lt;listenerId, fn&gt;&gt;</span>
<span class="hljs-addition">+ const listenersRef = useRef(new Map());</span>

<span class="hljs-addition">+ // Generate unique ids (node/modern browsers)</span>
<span class="hljs-addition">+ const makeId = () =&gt;</span>
<span class="hljs-addition">+   (typeof crypto !== "undefined" &amp;&amp; crypto.randomUUID)</span>
<span class="hljs-addition">+     ? crypto.randomUUID()</span>
<span class="hljs-addition">+     : `l_${Math.random().toString(36).slice(2)}`;</span>

<span class="hljs-addition">+ const addEventListener = useCallback((eventName, fn, opts = {}) =&gt; {</span>
<span class="hljs-addition">+   if (!eventName || typeof fn !== "function") return () =&gt; {};</span>
<span class="hljs-addition">+   let map = listenersRef.current.get(eventName);</span>
<span class="hljs-addition">+   if (!map) {</span>
<span class="hljs-addition">+     map = new Map();</span>
<span class="hljs-addition">+     listenersRef.current.set(eventName, map);</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   const id = opts.id || makeId();</span>
<span class="hljs-addition">+   map.set(id, fn);</span>
<span class="hljs-addition">+   // Return unsubscribe</span>
<span class="hljs-addition">+   return () =&gt; {</span>
<span class="hljs-addition">+     const m = listenersRef.current.get(eventName);</span>
<span class="hljs-addition">+     if (!m) return;</span>
<span class="hljs-addition">+     m.delete(id);</span>
<span class="hljs-addition">+     if (m.size === 0) listenersRef.current.delete(eventName);</span>
<span class="hljs-addition">+   };</span>
<span class="hljs-addition">+ }, []);</span>

<span class="hljs-addition">+ const removeEventListener = useCallback((eventName, id) =&gt; {</span>
<span class="hljs-addition">+   const m = listenersRef.current.get(eventName);</span>
<span class="hljs-addition">+   if (!m) return;</span>
<span class="hljs-addition">+   m.delete(id);</span>
<span class="hljs-addition">+   if (m.size === 0) listenersRef.current.delete(eventName);</span>
<span class="hljs-addition">+ }, []);</span>
</code></pre>
<h2>2) Bind a dispatcher to each p5 event when the instance is created</h2>
<p>Right after you create the instance (inside the <code>sketch</code> function), wire p5’s event hooks to a dispatcher that calls <strong>all</strong> current listeners. This is re-run on recreate, but uses the <strong>same listenersRef</strong>, so subscriptions survive recreates.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes">const sketch = (p5) =&gt; {
  p5Ref.current = p5;

<span class="hljs-addition">+ // helper: call all listeners for an eventName; combine return values</span>
<span class="hljs-addition">+ const dispatch = (eventName, arg) =&gt; {</span>
<span class="hljs-addition">+   const m = listenersRef.current.get(eventName);</span>
<span class="hljs-addition">+   if (!m || m.size === 0) return undefined;</span>
<span class="hljs-addition">+   let anyTruthy = false;</span>
<span class="hljs-addition">+   for (const fn of m.values()) {</span>
<span class="hljs-addition">+     try {</span>
<span class="hljs-addition">+       const res = fn(p5, arg);</span>
<span class="hljs-addition">+       if (res) anyTruthy = true;</span>
<span class="hljs-addition">+     } catch (e) {</span>
<span class="hljs-addition">+       console.error(`[P5.Canvas:${id}] listener error for ${eventName}`, e);</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+   }</span>
<span class="hljs-addition">+   // p5 uses return value for some events (e.g., mouseWheel prevent default)</span>
<span class="hljs-addition">+   return anyTruthy;</span>
<span class="hljs-addition">+ };</span>

<span class="hljs-addition">+ // Bind common p5 instance events to the dispatcher</span>
<span class="hljs-addition">+ p5.mouseMoved     = (e) =&gt; dispatch("mouseMoved", e);</span>
<span class="hljs-addition">+ p5.mousePressed   = (e) =&gt; dispatch("mousePressed", e);</span>
<span class="hljs-addition">+ p5.mouseDragged   = (e) =&gt; dispatch("mouseDragged", e);</span>
<span class="hljs-addition">+ p5.mouseReleased  = (e) =&gt; dispatch("mouseReleased", e);</span>
<span class="hljs-addition">+ p5.doubleClicked  = (e) =&gt; dispatch("doubleClicked", e);</span>
<span class="hljs-addition">+ p5.mouseWheel     = (e) =&gt; dispatch("mouseWheel", e);</span>
<span class="hljs-addition">+ p5.keyPressed     = (e) =&gt; dispatch("keyPressed", e);</span>
<span class="hljs-addition">+ p5.keyReleased    = (e) =&gt; dispatch("keyReleased", e);</span>
<span class="hljs-addition">+ p5.keyTyped       = (e) =&gt; dispatch("keyTyped", e);</span>
<span class="hljs-addition">+ p5.touchStarted   = (e) =&gt; dispatch("touchStarted", e);</span>
<span class="hljs-addition">+ p5.touchMoved     = (e) =&gt; dispatch("touchMoved", e);</span>
<span class="hljs-addition">+ p5.touchEnded     = (e) =&gt; dispatch("touchEnded", e);</span>

  p5.setup = () =&gt; {
    // ...
  };
};
</code></pre>
<blockquote>
<p>Note: returning a truthy value from any listener will cause the dispatcher to return truthy to p5. For <code>mouseWheel</code>, that signals “handled” and prevents default scrolling — a useful “OR” semantic for shared handlers.</p>
</blockquote>
<h2>3) Expose add/remove through context</h2>
<p>Include these in the <code>CanvasContext</code> value (like you already do with <code>setDraw</code>, etc.):</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes">const canvasCtxValue = useMemo(
<span class="hljs-deletion">-  () =&gt; ({ id, setPreloadSpec, setSetupSpec, setDraw, recreate }),</span>
<span class="hljs-deletion">-  [id, setPreloadSpec, setSetupSpec, setDraw, recreate],</span>
<span class="hljs-addition">+  () =&gt; ({ id, setPreloadSpec, setSetupSpec, setDraw, recreate, addEventListener, removeEventListener }),</span>
<span class="hljs-addition">+  [id, setPreloadSpec, setSetupSpec, setDraw, recreate, addEventListener, removeEventListener],</span>
);
</code></pre>
<p>Your existing provider/registry pattern will make these reachable via your hooks (e.g., inside <code>useP5(id)</code> you can expose them alongside size/ready/etc.).</p>

<h1>A tiny helper hook (ergonomics)</h1>
<p>Add a sugar hook so users can write:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-title function_">useP5Event</span>(<span class="hljs-string">"game"</span>, <span class="hljs-string">"mouseMoved"</span>, <span class="hljs-function">(<span class="hljs-params">p5, e</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<p>Implementation:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// src/lib/p5/hooks/useP5Event.js</span>
<span class="hljs-keyword">import</span> { useEffect, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { useP5 } <span class="hljs-keyword">from</span> <span class="hljs-string">"../hooks/useP5"</span>; <span class="hljs-comment">// your existing hook</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP5Event</span>(<span class="hljs-params">id, eventName, handler, deps = []</span>) {
  <span class="hljs-keyword">const</span> { addEventListener } = <span class="hljs-title function_">useP5</span>(id); <span class="hljs-comment">// expose via useP5</span>
  <span class="hljs-keyword">const</span> stableHandler = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> handler, deps);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!addEventListener || <span class="hljs-keyword">typeof</span> stableHandler !== <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> unsubscribe = <span class="hljs-title function_">addEventListener</span>(eventName, stableHandler);
    <span class="hljs-keyword">return</span> unsubscribe;
  }, [addEventListener, eventName, stableHandler]);
}
</code></pre>
<p>(If you prefer, accept an <code>options.id</code> and pass it through; otherwise the unsubscribe closure is plenty ergonomic.)</p>

<h1>Why this solves your concerns</h1>
<ul>
<li>
<p><strong>Multiple listeners:</strong> We multiplex p5’s single hook to your Map of handlers.</p>
</li>
<li>
<p><strong>Unsubscribe:</strong> We return an unsubscribe function; no need for consumers to juggle IDs. If you want a manual ID path, support <code>{ id }</code> in <code>opts</code>.</p>
</li>
<li>
<p><strong>No asset-reset side effects:</strong> We don’t touch <code>setup</code>/<code>preload</code>. Listeners live in a ref and are rebound to new instances on recreate without being lost (your recreate path remains reserved for <code>Setup</code>/<code>Preload</code>/renderer changes).</p>
</li>
<li>
<p><strong>StrictMode-safe:</strong> Listeners are stored outside the p5 instance; remount/recreate doesn’t lose them.</p>
</li>
</ul>

<h1>Example usage</h1>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useP5, useP5Event } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Crosshair</span>(<span class="hljs-params">{ id = <span class="hljs-string">"demo"</span> }</span>) {
  <span class="hljs-comment">// Subscribe with a stable handler</span>
  <span class="hljs-title function_">useP5Event</span>(id, <span class="hljs-string">"mouseMoved"</span>, <span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> {
    <span class="hljs-comment">// e optional; use p5.mouseX/Y</span>
    p5.<span class="hljs-title function_">cursor</span>(<span class="hljs-string">"crosshair"</span>);
  }, []); <span class="hljs-comment">// deps for memoization of handler</span>

  <span class="hljs-comment">// Subscribe to mouseWheel; returning true prevents default scrolling</span>
  <span class="hljs-title function_">useP5Event</span>(id, <span class="hljs-string">"mouseWheel"</span>, <span class="hljs-function">(<span class="hljs-params">p5, e</span>) =&gt;</span> {
    <span class="hljs-comment">// zoom example</span>
    <span class="hljs-comment">// return true to "consume" the event</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }, []);

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">// In your canvas:</span>
&lt;<span class="hljs-variable constant_">P5</span>.<span class="hljs-property">Canvas</span> id=<span class="hljs-string">"demo"</span> width={<span class="hljs-number">800</span>} height={<span class="hljs-number">600</span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.Setup</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> p5.background(32)} /&gt;</span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.Draw</span> <span class="hljs-attr">fn</span>=<span class="hljs-string">{(p5)</span> =&gt;</span> { /* ... */ }} /&gt;</span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Crosshair</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> /&gt;</span></span>
&lt;/<span class="hljs-variable constant_">P5</span>.<span class="hljs-property">Canvas</span>&gt;
</code></pre>

<p>If you want, I can also wire <code>addEventListener/removeEventListener</code> through your <code>useP5(id)</code> return object (e.g., <code>{ addEventListener, removeEventListener }</code>) so you don’t need a separate hook. Either way, this integrates cleanly with your context/provider architecture and preserves your hot-swap behaviors for <code>Draw</code>.</p>Sources</div>
        </div>
      
        <div class="message user-message">
          <div class="content">Great. I appreciate your solution, but I think I'll take this opportunity to add additional requirements.
I want to be able to support the concept of Scenes, so I think a refactor of the API is in order.

Here's my stub design:

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotImplementedError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TypeError</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">cls, method</span>) {
        <span class="hljs-comment">// set message saying abstract method {cls}.{method}({signature}) is not implemented</span>
    }
    <span class="hljs-comment">// ...</span>
}


<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractP5Scene</span> {
    <span class="hljs-keyword">static</span> scene = <span class="hljs-literal">null</span>

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">AbstractP5Scene</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Cannot instantiate an abstract class directly."</span>)
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>.<span class="hljs-property">scene</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-string">'string'</span> || !<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>.<span class="hljs-property">scene</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(
                <span class="hljs-string">`Static 'scene' property on class <span class="hljs-subst">${<span class="hljs-keyword">new</span>.target.name}</span> needs to be set with a non-empty string value`</span>
            )
        }
    }

    <span class="hljs-comment">/**
     * Function to preload assets that take time to load.
     * Called when context.preload(scene: string) is called with a scene value matching this.
     * 
     * <span class="hljs-doctag">@param</span> p5 {P5}
     * <span class="hljs-doctag">@param</span> context {P5Context}
     */</span>
    <span class="hljs-title function_">preload</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">preload</span>)
    }

    <span class="hljs-comment">/**
     * Mimicks setup function in p5.
     * Use this to setup state/styles that are permanent for the duration of the scene. 
     * Will be executed as part of the first draw cycle this scene will be drawn on.
     * 
     * <span class="hljs-doctag">@param</span> p5 {P5} 
     * <span class="hljs-doctag">@param</span> context {P5Context} 
     */</span>
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">setup</span>)
    }

    <span class="hljs-comment">/**
     * Mimicks draw function in p5.
     * Use this to draw your content on the canvas on every draw cycle
     * 
     * <span class="hljs-doctag">@param</span> p5 {P5}
     * <span class="hljs-doctag">@param</span> context {P5Context}
     */</span>
    <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">draw</span>)
    }

    <span class="hljs-comment">/**
     * Function to unset any state/clear memory.
     * Will be executed asynchronously not to lock the main thread.
     * 
     * <span class="hljs-doctag">@param</span> p5 {P5}
     * <span class="hljs-doctag">@param</span> context {P5Context}
     */</span>
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">destroy</span>)
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Scene1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
    
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-comment">// load some resources; should we have another method for eager loading assets</span>
        <span class="hljs-comment">// before scene transition, and then let scenes emit an event to signal to load</span>
        <span class="hljs-comment">// next scene's assets?</span>
        <span class="hljs-keyword">const</span> { addEventListener } = context
        <span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'my-handler-name'</span>, <span class="hljs-string">'mouseMoved'</span>, <span class="hljs-function">(<span class="hljs-params">p5, context</span>) =&gt;</span> {
            <span class="hljs-comment">// ...</span>
        })
    }

    <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">async</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">p5, context</span>) {
        <span class="hljs-keyword">const</span> { removeEventListener } = context
        <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-comment">/* ... */</span>)
    }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">P5App</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span>
                <span class="hljs-attr">id</span>=<span class="hljs-string">"art-jam-i"</span>
                <span class="hljs-attr">renderer</span>=<span class="hljs-string">{</span>"<span class="hljs-attr">WEBGL</span>"}
                <span class="hljs-attr">width</span>=<span class="hljs-string">{width}</span>
                <span class="hljs-attr">height</span>=<span class="hljs-string">{height}</span>
                <span class="hljs-attr">setup</span>=<span class="hljs-string">{setupFn}</span>
                <span class="hljs-attr">scene</span>=<span class="hljs-string">{scene}</span> /* <span class="hljs-attr">if</span> <span class="hljs-attr">not</span> <span class="hljs-attr">provided</span>, <span class="hljs-attr">first</span> <span class="hljs-attr">P5.Scene</span> <span class="hljs-attr">child</span> <span class="hljs-attr">is</span> <span class="hljs-attr">loaded</span> */
            &gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">name</span>=<span class="hljs-string">{</span>"<span class="hljs-attr">scene1</span>"} <span class="hljs-attr">cls</span>=<span class="hljs-string">{Scene1}</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">name</span>=<span class="hljs-string">{</span>"<span class="hljs-attr">scene2</span>"} <span class="hljs-attr">cls</span>=<span class="hljs-string">{Scene2}</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
    )
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">P5Scene</span>(<span class="hljs-params">{ id, cls }</span>) {
    <span class="hljs-comment">// update P5.Canvas state by adding the Scene class</span>
    
}</code></pre>

What do you think?
</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Love this direction. A “Scene Manager” layered into your <code>&lt;P5.Canvas&gt;</code> is a natural fit with your context-based API. Here’s a tight plan plus drop-in code to get you moving.</p>
<h1>Key adjustments to your stub</h1>
<ul>
<li>
<p><code>NotImplementedError</code>: build message from class + method name.</p>
</li>
<li>
<p>Static name check: <code>typeof this.constructor.scene === 'string'</code> (your <code>instanceof 'string'</code> won’t work).</p>
</li>
<li>
<p>Scenes should be <strong>registered declaratively</strong> via <code>&lt;P5.Scene name cls /&gt;</code> children; Canvas owns lifecycle (preload → first-setup-on-entry → draw → destroy-on-exit).</p>
</li>
<li>
<p>Add <strong>scene-scoped event listeners</strong> so they’re automatically cleaned up on scene switch.</p>
</li>
</ul>

<h2>1) Abstract + error helpers</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotImplementedError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TypeError</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">cls, methodFn</span>) {
    <span class="hljs-keyword">const</span> method = (methodFn &amp;&amp; methodFn.<span class="hljs-property">name</span>) || <span class="hljs-string">'&lt;anonymous&gt;'</span>;
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">`Abstract method <span class="hljs-subst">${cls.name}</span>.<span class="hljs-subst">${method}</span>() is not implemented`</span>);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">p5, context</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">AbstractP5Scene</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Cannot instantiate an abstract class directly."</span>);
    }
    <span class="hljs-keyword">const</span> s = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">scene</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s !== <span class="hljs-string">"string"</span> || !s.<span class="hljs-title function_">trim</span>()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(
        <span class="hljs-string">`Static 'scene' property on <span class="hljs-subst">${<span class="hljs-keyword">new</span>.target.name}</span> must be a non-empty string`</span>
      );
    }
  }

  <span class="hljs-title function_">preload</span>(<span class="hljs-params">p5, ctx</span>)  { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">preload</span>); }
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>)    { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">setup</span>); }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5, ctx</span>)     { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">draw</span>); }
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-comment">/* optional, default no-op */</span> }
}
</code></pre>
<blockquote>
<p>You can still allow <code>&lt;P5.Scene name="..." cls={Scene1} /&gt;</code> to <strong>override</strong> <code>static scene</code>.</p>
</blockquote>

<h2>2) Register scenes declaratively</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// src/lib/p5/components/P5Scene.jsx</span>
<span class="hljs-keyword">import</span> { useContext, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Scene</span>(<span class="hljs-params">{ name, cls }</span>) {
  <span class="hljs-keyword">const</span> ctx = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CanvasContext</span>);
  <span class="hljs-keyword">if</span> (!ctx) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Scene&gt; must be inside &lt;P5.Canvas&gt;."</span>);
  <span class="hljs-keyword">const</span> sceneName = name || (cls &amp;&amp; cls.<span class="hljs-property">scene</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    ctx.<span class="hljs-title function_">registerScene</span>(sceneName, cls);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> ctx.<span class="hljs-title function_">unregisterScene</span>(sceneName);
  }, [ctx, sceneName, cls]);

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// declarative registration only</span>
}
</code></pre>
<p>Expose it via your barrel as <code>P5.Scene</code>.</p>

<h2>3) Canvas: scene manager (preload, setup, draw, destroy)</h2>
<p>Add a <strong>scene registry</strong> and a <strong>current scene controller</strong> inside <code>&lt;P5.Canvas&gt;</code>.</p>
<h3>New refs/state inside Canvas</h3>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> scenesRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()); <span class="hljs-comment">// name -&gt; { cls, instance?, status }</span>
<span class="hljs-keyword">const</span> currentSceneRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// name</span>
<span class="hljs-keyword">const</span> sceneSubscriptionsRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()); <span class="hljs-comment">// unsubscribe fns (scoped)</span>
<span class="hljs-keyword">const</span> preloadPromisesRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()); <span class="hljs-comment">// name -&gt; Promise</span>
</code></pre>
<h3>Scene APIs on context</h3>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> registerScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">name, cls</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!name || !cls) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (!scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(name)) scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(name, { cls, <span class="hljs-attr">status</span>: <span class="hljs-string">'idle'</span> });
  <span class="hljs-keyword">else</span> scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name).<span class="hljs-property">cls</span> = cls;
}, []);

<span class="hljs-keyword">const</span> unregisterScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
  scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(name);
  <span class="hljs-keyword">if</span> (currentSceneRef.<span class="hljs-property">current</span> === name) {
    <span class="hljs-comment">// optional: clear current or auto-switch elsewhere</span>
  }
}, []);

<span class="hljs-keyword">const</span> preloadScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> (name) =&gt; {
  <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
  <span class="hljs-keyword">if</span> (!rec) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(name)) <span class="hljs-keyword">return</span> preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> p5 = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> ctx = <span class="hljs-title function_">publicCtx</span>(); <span class="hljs-comment">// build a scene-safe ctx (see below)</span>
    <span class="hljs-keyword">if</span> (rec.<span class="hljs-property">instance</span> == <span class="hljs-literal">null</span>) rec.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> rec.<span class="hljs-title function_">cls</span>(p5, ctx);
    <span class="hljs-keyword">if</span> (rec.<span class="hljs-property">instance</span>.<span class="hljs-property">preload</span>) <span class="hljs-keyword">await</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">preload</span>(p5, ctx);
    rec.<span class="hljs-property">status</span> = <span class="hljs-string">'preloaded'</span>;
  };
  <span class="hljs-keyword">const</span> prom = <span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e); rec.<span class="hljs-property">status</span>=<span class="hljs-string">'idle'</span>; });
  preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(name, prom);
  <span class="hljs-keyword">return</span> prom;
}, []);
</code></pre>
<h3>Switch scenes (with destroy + setup + scoped listeners)</h3>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> <span class="hljs-title function_">clearSceneSubscriptions</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> unsub <span class="hljs-keyword">of</span> sceneSubscriptionsRef.<span class="hljs-property">current</span>) { <span class="hljs-keyword">try</span> { <span class="hljs-title function_">unsub</span>(); } <span class="hljs-keyword">catch</span> {} }
  sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">clear</span>();
};

<span class="hljs-keyword">const</span> setScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> (name) =&gt; {
  <span class="hljs-keyword">if</span> (!name || currentSceneRef.<span class="hljs-property">current</span> === name) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">const</span> p5 = p5Ref.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">const</span> next = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
  <span class="hljs-keyword">if</span> (!next) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">const</span> prevName = currentSceneRef.<span class="hljs-property">current</span>;
  <span class="hljs-keyword">const</span> prev = prevName ? scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(prevName) : <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// destroy previous scene (async, non-blocking draw)</span>
  <span class="hljs-keyword">if</span> (prev &amp;&amp; prev.<span class="hljs-property">instance</span> &amp;&amp; prev.<span class="hljs-property">instance</span>.<span class="hljs-property">destroy</span>) {
    <span class="hljs-comment">// best effort cleanup; do not await to keep UI responsive</span>
    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(prev.<span class="hljs-property">instance</span>.<span class="hljs-title function_">destroy</span>(p5, <span class="hljs-title function_">publicCtx</span>())).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
  }
  <span class="hljs-title function_">clearSceneSubscriptions</span>();

  <span class="hljs-comment">// ensure preload</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">preloadScene</span>(name);

  <span class="hljs-comment">// ensure instance + setup-on-first-enter</span>
  <span class="hljs-keyword">if</span> (next.<span class="hljs-property">instance</span> == <span class="hljs-literal">null</span>) next.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> next.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">publicCtx</span>());
  <span class="hljs-keyword">if</span> (next.<span class="hljs-property">status</span> !== <span class="hljs-string">'setup'</span>) {
    <span class="hljs-keyword">if</span> (next.<span class="hljs-property">instance</span>.<span class="hljs-property">setup</span>) next.<span class="hljs-property">instance</span>.<span class="hljs-title function_">setup</span>(p5, <span class="hljs-title function_">publicCtx</span>());
    next.<span class="hljs-property">status</span> = <span class="hljs-string">'setup'</span>;
  }

  currentSceneRef.<span class="hljs-property">current</span> = name;
}, [preloadScene]);
</code></pre>
<h3>Dispatch draw to active scene</h3>
<p>In your existing p5 <code>setup</code> inside the create effect, bind a <strong>single draw</strong> that delegates:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes">p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> active = currentSceneRef.<span class="hljs-property">current</span> &amp;&amp; scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(currentSceneRef.<span class="hljs-property">current</span>);
  <span class="hljs-keyword">if</span> (active &amp;&amp; active.<span class="hljs-property">instance</span> &amp;&amp; active.<span class="hljs-property">instance</span>.<span class="hljs-property">draw</span>) {
    active.<span class="hljs-property">instance</span>.<span class="hljs-title function_">draw</span>(p5, <span class="hljs-title function_">publicCtx</span>());
  }
};
p5.<span class="hljs-title function_">loop</span>();
</code></pre>
<blockquote>
<p>You can still allow <code>&lt;P5.Draw&gt;</code> for simple sketches, but with scenes it’s cleaner to control via <code>setScene()</code> and the scene class methods.</p>
</blockquote>
<h3>Scene-scoped event listeners (auto-clean)</h3>
<p>Re-use your earlier multi-listener plan, but add a <strong>scene-scoped helper</strong> that auto-unsubscribes on switch:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> addEventListener = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, fn, opts = {}</span>) =&gt;</span> {
  <span class="hljs-comment">// ... your Map(eventName -&gt; Map(id -&gt; fn)) as previously discussed ...</span>
  <span class="hljs-comment">// return unsubscribe;</span>
}, []);

<span class="hljs-keyword">const</span> addEventListenerScoped = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, fn, opts={}</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> unsub = <span class="hljs-title function_">addEventListener</span>(eventName, fn, opts);
  sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">add</span>(unsub);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">try</span> { <span class="hljs-title function_">unsub</span>(); } <span class="hljs-keyword">finally</span> { sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(unsub); } };
}, [addEventListener]);
</code></pre>
<h3>Expose a <strong>scene-aware context</strong> to scenes</h3>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> <span class="hljs-title function_">publicCtx</span> = (<span class="hljs-params"></span>) =&gt; ({
  id,
  <span class="hljs-attr">addEventListener</span>: <span class="hljs-function">(<span class="hljs-params">ev, fn, opts</span>) =&gt;</span> <span class="hljs-title function_">addEventListener</span>(ev, fn, opts),
  removeEventListener, <span class="hljs-comment">// if you keep the id-based API too</span>
  addEventListenerScoped, <span class="hljs-comment">// recommended for scenes</span>
  <span class="hljs-attr">preload</span>: preloadScene,
  setScene, <span class="hljs-comment">// allow scene-driven transitions</span>
  <span class="hljs-attr">size</span>: { width, height },
  <span class="hljs-attr">registryUpdate</span>: <span class="hljs-function">(<span class="hljs-params">patch</span>) =&gt;</span> <span class="hljs-title function_">updateCanvas</span>(id, patch),
});
</code></pre>
<h3>Provide on <code>CanvasContext</code> so <code>&lt;P5.Scene&gt;</code> and app code can call</h3>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> canvasCtxValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({
  id,
  <span class="hljs-comment">// existing setters...</span>
  registerScene, unregisterScene,
  <span class="hljs-attr">preload</span>: preloadScene,
  setScene,
  addEventListener, addEventListenerScoped, removeEventListener,
}), [<span class="hljs-comment">/* deps */</span>]);
</code></pre>
<h3>Choose initial scene</h3>
<p>When Canvas first boots (after your existing <code>bootReady</code>), if:</p>
<ul>
<li>
<p>a <code>scene</code> prop is provided → <code>await setScene(scene)</code></p>
</li>
<li>
<p>else if there is at least one <code>&lt;P5.Scene&gt;</code> child registered → set to the <strong>first one</strong> (or a <code>defaultScene</code> prop).</p>
</li>
</ul>
<p>Call <code>setScene</code> <strong>after</strong> the p5 instance is created.</p>

<h2>4) Usage</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scene1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"scene1"</span>;
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>) {
    <span class="hljs-comment">// scoped listener auto-cleans on scene switch</span>
    ctx.<span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-string">"mouseMoved"</span>, <span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> p5.<span class="hljs-title function_">cursor</span>(<span class="hljs-string">"crosshair"</span>));
  }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5</span>) {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">20</span>);
    p5.<span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>); p5.<span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Scene2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"scene2"</span>;
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">preload</span>(<span class="hljs-params">p5</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> i = p5.<span class="hljs-title function_">loadImage</span>(<span class="hljs-string">"/hero.png"</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">res</span>(i));
    });
  }
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5</span>) { p5.<span class="hljs-title function_">imageMode</span>(p5.<span class="hljs-property">CENTER</span>); }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5</span>)  { <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span>) p5.<span class="hljs-title function_">image</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span>, p5.<span class="hljs-property">width</span>/<span class="hljs-number">2</span>, p5.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>); }
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">p5</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span> &amp;&amp; (<span class="hljs-variable language_">this</span>.<span class="hljs-property">img</span> = <span class="hljs-literal">null</span>); }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">P5App</span>(<span class="hljs-params">{ scene }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span> <span class="hljs-attr">renderer</span>=<span class="hljs-string">"P2D"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{600}</span> <span class="hljs-attr">scene</span>=<span class="hljs-string">{scene}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">cls</span>=<span class="hljs-string">{Scene1}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">cls</span>=<span class="hljs-string">{Scene2}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<p>To trigger transitions:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> { setScene, preload } = <span class="hljs-title function_">useP5</span>(<span class="hljs-string">"app"</span>); <span class="hljs-comment">// expose these via your useP5 hook</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">preload</span>(<span class="hljs-string">"scene2"</span>); <span class="hljs-comment">// optional eager warm-up</span>
<span class="hljs-title function_">setScene</span>(<span class="hljs-string">"scene2"</span>);
</code></pre>

<h2>Why this design works</h2>
<ul>
<li>
<p><strong>Declarative registration</strong> keeps Scene definitions colocated with Canvas usage.</p>
</li>
<li>
<p><strong>Boot barrier</strong> + registry ensures <strong>preload/setup</strong> are known before first <code>draw</code>.</p>
</li>
<li>
<p><strong>Scene-scoped listeners</strong> give you multiple handlers and <strong>automatic cleanup</strong> on transition.</p>
</li>
<li>
<p><strong>Preload API</strong> allows <strong>eager loading</strong> (menu can preload the next scene) and the scene can <strong>self-transition</strong> via <code>context.setScene(...)</code>.</p>
</li>
<li>
<p>Scenes, assets, and listeners <strong>survive Canvas recreates</strong> (renderer change) because the registries live in refs and are re-bound on re-init.</p>
</li>
</ul>
<p>If you want, I can package the deltas as small patches to your current <code>Canvas.jsx</code> so you can drop them in directly.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Great. Notes:

1. AbstractP5Scene should have fully documented methods, with arg types, so that intellisense can work out of the box

2. addEventListenerScoped is not implemented, can you explain what it is?

3. updateCanvas is not implemented, can you explain what it is? what is registryUpdate for?

4. What is the difference between publicCtx and canvasCtxValue in terms of usage?

5. Could it be possible to have the context that is passed to the scenes to be a class instead of a plain javascript object? that way intellisense can work.</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Awesome—here are crisp answers + concrete code you can drop in.</p>

<h1>1) Fully documented <code>AbstractP5Scene</code> (with IntelliSense)</h1>
<p>Use JSDoc types so editors infer everything even in plain JS.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// src/lib/p5/scenes/AbstractP5Scene.js</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('p5')</span>} <span class="hljs-variable">P5</span>
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('../types').SceneContext</span>} <span class="hljs-variable">SceneContext</span>
 */</span>

<span class="hljs-comment">/** Error used for abstract methods. */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotImplementedError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TypeError</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">cls</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">methodFn</span>
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">cls, methodFn</span>) {
    <span class="hljs-keyword">const</span> method = (methodFn &amp;&amp; methodFn.<span class="hljs-property">name</span>) || <span class="hljs-string">'&lt;anonymous&gt;'</span>;
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">`Abstract method <span class="hljs-subst">${cls.name}</span>.<span class="hljs-subst">${method}</span>() is not implemented`</span>);
  }
}

<span class="hljs-comment">/**
 * Base class for all scenes. Extend and implement lifecycle methods.
 * <span class="hljs-doctag">@abstract</span>
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractP5Scene</span> {
  <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">string|null</span>} A unique scene key (may be overridden by &lt;P5.Scene name=...&gt;) */</span>
  <span class="hljs-keyword">static</span> scene = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">_p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">_ctx</span>
   * <span class="hljs-doctag">@throws</span> {<span class="hljs-type">TypeError</span>}
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">_p5, _ctx</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">AbstractP5Scene</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Cannot instantiate AbstractP5Scene directly."</span>);
    }
    <span class="hljs-keyword">const</span> s = <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">*</span>} */</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>).<span class="hljs-property">scene</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s !== <span class="hljs-string">"string"</span> || !s.<span class="hljs-title function_">trim</span>()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`Static 'scene' must be a non-empty string on <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.constructor.name}</span>`</span>);
    }
  }

  <span class="hljs-comment">/**
   * Preload heavy assets (images, fonts, shaders...). Called when
   * `ctx.preload(sceneName)` resolves for this scene.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void|Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-title function_">preload</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">preload</span>); }

  <span class="hljs-comment">/**
   * One-time setup right before the scene is drawn the first time.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
   */</span>
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">setup</span>); }

  <span class="hljs-comment">/**
   * Draw loop for this scene (called each frame).
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
   */</span>
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">draw</span>); }

  <span class="hljs-comment">/**
   * Cleanup when leaving the scene (free textures, detach listeners, etc).
   * Executed asynchronously; you may `await` long tasks if needed.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">_p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">_ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void|Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">_p5, _ctx</span>) { <span class="hljs-comment">/* optional */</span> }
}
</code></pre>

<h1>2) What is <code>addEventListenerScoped</code>?</h1>
<p>It registers a listener like <code>addEventListener</code>, <strong>but also remembers it for the <em>current</em> scene</strong>, so it’s automatically removed when you switch scenes. It returns an <code>unsubscribe()</code> function too.</p>
<ul>
<li>
<p><code>addEventListener(event, fn)</code> → multiplexer registry (you already have)</p>
</li>
<li>
<p><code>addEventListenerScoped(event, fn)</code> → same, plus auto-unsub on scene change</p>
</li>
</ul>
<p>This lets scene code do:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes">ctx.<span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-string">"mouseMoved"</span>, <span class="hljs-function">(<span class="hljs-params">p5, e</span>) =&gt;</span> { <span class="hljs-comment">/* ... */</span> });
</code></pre>
<p>…and not worry about cleanup in <code>destroy()</code> (though you still can).</p>
<p><strong>Canvas internal (excerpt):</strong></p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> sceneSubscriptionsRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()); <span class="hljs-comment">// Set&lt;() =&gt; void&gt;</span>

<span class="hljs-keyword">const</span> addEventListenerScoped = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, fn, opts={}</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> unsub = <span class="hljs-title function_">addEventListener</span>(eventName, fn, opts);
  sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">add</span>(unsub);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> { <span class="hljs-title function_">unsub</span>(); } <span class="hljs-keyword">finally</span> { sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(unsub); }
  };
}, [addEventListener]);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">clearSceneSubscriptions</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> unsub <span class="hljs-keyword">of</span> sceneSubscriptionsRef.<span class="hljs-property">current</span>) { <span class="hljs-keyword">try</span> { <span class="hljs-title function_">unsub</span>(); } <span class="hljs-keyword">catch</span> {} }
  sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">clear</span>();
};

<span class="hljs-comment">// When switching scenes (before activating the next):</span>
<span class="hljs-title function_">clearSceneSubscriptions</span>();
</code></pre>

<h1>3) What is <code>updateCanvas</code> / <code>registryUpdate</code>?</h1>
<p>You already call <code>updateCanvas(id, patch)</code> in <code>Canvas.jsx</code>. That comes from your <code>RegistryContext</code> and should <strong>mutate the registry entry</strong> for a given canvas (e.g., <code>{ ready, size, p5Ref, canvasRef }</code>). Hooks like <code>useP5(id)</code> read from that registry.</p>
<ul>
<li>
<p><strong><code>updateCanvas(id, patch)</code></strong> (existing): internal context function that merges a partial update into the canvas record.</p>
</li>
<li>
<p><strong><code>registryUpdate</code></strong> (my earlier mention): simply meant “use <code>updateCanvas</code>.” You don’t need two names—keep <code>updateCanvas</code>.</p>
</li>
</ul>
<p>So: keep using <code>updateCanvas(id, { ready: true })</code>, etc. If you want to expose a <em>safe</em> updater to scenes (e.g., to stash per-scene status), pass a <strong>curated</strong> method in the SceneContext instead of the raw <code>updateCanvas</code>.</p>

<h1>4) <code>publicCtx</code> vs <code>canvasCtxValue</code></h1>
<ul>
<li>
<p><strong><code>canvasCtxValue</code></strong>: the <strong>React context value</strong> you provide to children (<code>&lt;P5.Setup&gt;</code>, <code>&lt;P5.Draw&gt;</code>, <code>&lt;P5.Scene&gt;</code>). It contains internal wiring methods (e.g. <code>registerScene</code>, <code>setDraw</code>, <code>recreate</code>…), used by your <em>components</em> to register themselves.</p>
</li>
<li>
<p><strong><code>publicCtx</code> (now a class, see below)</strong>: the <strong>runtime API handed to scenes at draw-time</strong>. It’s a narrow, stable surface tailored for scene code: events, preload, setScene, size, ids… No React-y internals, just what a scene needs. Think “capability object.”</p>
</li>
</ul>
<p>TL;DR: components use <code>canvasCtxValue</code>; scenes receive <code>publicCtx</code>.</p>

<h1>5) Class-based context for scenes (IntelliSense-friendly)</h1>
<p>Yes—define a <code>SceneContext</code> class, constructed in <code>Canvas</code>, that closes over the necessary callbacks/refs. Scenes receive <strong>an instance</strong> of this class in <code>preload/setup/draw/destroy</code>, so editors can show rich intellisense.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// src/lib/p5/types.js</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('p5')</span>} <span class="hljs-variable">P5</span>
 */</span>

<span class="hljs-comment">/**
 * Context given to scene methods at runtime.
 * Methods are stable; they delegate into the Canvas internals.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneContext</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">args</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} args.id
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">() =&gt; {width:number,height:number</span>}} args.getSize
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(name:string)=&gt;Promise&lt;void&gt;</span>} args.preload
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(name:string)=&gt;Promise&lt;void&gt;</span>} args.setScene
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, fn:Function, opts?:{id?:string</span>}) =&gt; () =&gt; void} args.addEventListener
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, fn:Function, opts?:{id?:string</span>}) =&gt; () =&gt; void} args.addEventListenerScoped
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, id:string) =&gt; void</span>} args.removeEventListener
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">{ id, getSize, preload, setScene, addEventListener, addEventListenerScoped, removeEventListener }</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_getSize</span> = getSize;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_preload</span> = preload;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_setScene</span> = setScene;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_add</span> = addEventListener;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_addScoped</span> = addEventListenerScoped;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_remove</span> = removeEventListener;
  }

  <span class="hljs-comment">/** <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} */</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">id</span>() { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>; }

  <span class="hljs-comment">/** <span class="hljs-doctag">@returns</span> {<span class="hljs-type">{width:number,height:number</span>}} */</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">size</span>() { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getSize</span>(); }

  <span class="hljs-comment">/**
   * Eagerly load assets for a scene by name.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sceneName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-title function_">preload</span>(<span class="hljs-params">sceneName</span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_preload</span>(sceneName); }

  <span class="hljs-comment">/**
   * Transition to another scene by name.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sceneName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-title function_">setScene</span>(<span class="hljs-params">sceneName</span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_setScene</span>(sceneName); }

  <span class="hljs-comment">/**
   * Add a listener to a p5 event (multi-listener enabled). Returns unsubscribe.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(p5:P5, evt:any)=&gt;any</span>} <span class="hljs-variable">handler</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{id?:string</span>}} [opts]
   */</span>
  <span class="hljs-title function_">addEventListener</span>(<span class="hljs-params">eventName, handler, opts</span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_add</span>(eventName, handler, opts); }

  <span class="hljs-comment">/**
   * Like addEventListener, but auto-removed on scene switch. Returns unsubscribe.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(p5:P5, evt:any)=&gt;any</span>} <span class="hljs-variable">handler</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{id?:string</span>}} [opts]
   */</span>
  <span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-params">eventName, handler, opts</span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addScoped</span>(eventName, handler, opts); }

  <span class="hljs-comment">/**
   * Remove a listener by id (only needed if you used an explicit id).
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">id</span>
   */</span>
  <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-params">eventName, id</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_remove</span>(eventName, id); }
}
</code></pre>
<p><strong>Canvas wiring (where you create the instance):</strong></p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// inside Canvas component</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SceneContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types"</span>;

<span class="hljs-comment">// build a fresh instance each time you pass it, or cache it in a ref if you prefer</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getSize</span> = (<span class="hljs-params"></span>) =&gt; ({ width, height });

<span class="hljs-keyword">const</span> <span class="hljs-title function_">makeSceneContext</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SceneContext</span>({
  id,
  getSize,
  <span class="hljs-attr">preload</span>: preloadScene,
  setScene,
  addEventListener,
  addEventListenerScoped,
  removeEventListener,
});

<span class="hljs-comment">// When calling scene methods:</span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-title function_">makeSceneContext</span>();
<span class="hljs-keyword">if</span> (scene.<span class="hljs-property">instance</span>.<span class="hljs-property">preload</span>) <span class="hljs-keyword">await</span> scene.<span class="hljs-property">instance</span>.<span class="hljs-title function_">preload</span>(p5, ctx);
<span class="hljs-comment">// ...</span>
scene.<span class="hljs-property">instance</span>.<span class="hljs-title function_">draw</span>(p5, ctx);
</code></pre>
<p>This keeps the <strong>public API typed and discoverable</strong>, and you can evolve internals without changing scene code.</p>

<h2>Tiny usage example</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scene1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"scene1"</span>;
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>) {
    ctx.<span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-string">"mouseMoved"</span>, <span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> p5.<span class="hljs-title function_">cursor</span>(<span class="hljs-string">"crosshair"</span>));
  }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5, ctx</span>) {
    <span class="hljs-keyword">const</span> { width, height } = ctx.<span class="hljs-property">size</span>;
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);
    p5.<span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>); p5.<span class="hljs-title function_">circle</span>(width/<span class="hljs-number">2</span>, height/<span class="hljs-number">2</span>, <span class="hljs-number">40</span>);
  }
}
</code></pre>

<h2>Recap</h2>
<ul>
<li>
<p><strong><code>addEventListenerScoped</code></strong> = multi-listener + auto-clean on scene switch.</p>
</li>
<li>
<p><strong><code>updateCanvas</code></strong> = your existing registry updater; keep using it internally.</p>
</li>
<li>
<p><strong><code>publicCtx</code></strong> (now <code>SceneContext</code>) is a class handed to scenes; <strong><code>canvasCtxValue</code></strong> is the React context for child components.</p>
</li>
<li>
<p><strong><code>AbstractP5Scene</code></strong> now fully documented for IntelliSense.</p>
</li>
</ul>
<p>If you want, I can bundle the Canvas diffs (scene registry, switching, dispatch, and the two addEventListener flavors) into a single patch so you can paste it in one go.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Fantastic. I like all of this. Can you provide the full implementation, file by file?
Final notes:

- Do not expose ctx.size or a getSize; these can be taken directly from the p5 object.
- In SceneContext, please make all of the public methods bound to <code>this</code> so that the class can be deconstructed (or unless this wouldn't work with intellisense then scrap the idea; it's only for a better dx.
- Drop support for P5.Setup, P5.Draw.2/2</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Awesome—here’s a <strong>complete, drop-in implementation</strong> of the scene system and multi-listener events, file-by-file. It removes <code>&lt;P5.Setup&gt;</code> and <code>&lt;P5.Draw&gt;</code> (as requested), gives you IntelliSense via JSDoc, and uses a <strong>class</strong> <code>SceneContext</code> with bound methods so you can freely destructure it.</p>
<blockquote>
<p>Notes addressed:</p>
<ul>
<li>
<p><code>SceneContext</code> methods are bound (class fields) and fully typed via JSDoc.</p>
</li>
<li>
<p>No <code>ctx.size</code> or <code>getSize</code>; scenes should read <code>p5.width</code> / <code>p5.height</code>.</p>
</li>
<li>
<p><code>addEventListenerScoped</code> = multi-listener + auto-unsubscribe on scene switch.</p>
</li>
<li>
<p><code>updateCanvas</code> is provided by the registry; used internally by <code>&lt;P5.Canvas&gt;</code>.</p>
</li>
<li>
<p><code>publicCtx</code> (now <code>SceneContext</code>) is passed to scenes; <code>canvasCtxValue</code> is the internal React context value used by components like <code>&lt;P5.Scene&gt;</code>.</p>
</li>
</ul>
</blockquote>

<h3><code>src/lib/p5/p5.js</code></h3>
<p>A single p5 entry that also sets <code>window.p5</code> in the browser so plugins can patch the same instance.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"p5"</span>;

<span class="hljs-comment">// Browser global for plugins (e.g., p5.collide2d)</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; !<span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span>) {
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">p5</span> = p5js;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> p5js;
</code></pre>

<h3><code>src/lib/p5/types.js</code></h3>
<p><code>SceneContext</code> (class) with bound methods for great DX/IntelliSense.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('p5')</span>} <span class="hljs-variable">P5</span>
 */</span>

<span class="hljs-comment">/**
 * Public runtime API handed to scene methods.
 * All methods are bound so this class is safe to destructure.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneContext</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">args</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} args.id
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(sceneName:string)=&gt;Promise&lt;void&gt;</span>} args.preload
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(sceneName:string)=&gt;Promise&lt;void&gt;</span>} args.setScene
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, fn:(p5:P5, evt:any)=&gt;any, opts?:{id?:string</span>}) =&gt; () =&gt; void} args.addEventListener
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, fn:(p5:P5, evt:any)=&gt;any, opts?:{id?:string</span>}) =&gt; () =&gt; void} args.addEventListenerScoped
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, id:string) =&gt; void</span>} args.removeEventListener
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">{ id, preload, setScene, addEventListener, addEventListenerScoped, removeEventListener }</span>) {
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = id;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_preloadImpl</span> = preload;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_setSceneImpl</span> = setScene;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_addImpl</span> = addEventListener;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_addScopedImpl</span> = addEventListenerScoped;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_removeImpl</span> = removeEventListener;
  }

  <span class="hljs-comment">/** <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} */</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">id</span>() { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>; }

  <span class="hljs-comment">/**
   * Eagerly preload a scene's assets by name.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sceneName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;void&gt;</span>}
   */</span>
  preload = <span class="hljs-function">(<span class="hljs-params">sceneName</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_preloadImpl</span>(sceneName);

  <span class="hljs-comment">/**
   * Transition to another scene by name.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sceneName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;void&gt;</span>}
   */</span>
  setScene = <span class="hljs-function">(<span class="hljs-params">sceneName</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_setSceneImpl</span>(sceneName);

  <span class="hljs-comment">/**
   * Add a p5 event listener. Returns an unsubscribe function.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(p5:P5, evt:any)=&gt;any</span>} <span class="hljs-variable">handler</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{id?:string</span>}} [opts]
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">() =&gt; void</span>}
   */</span>
  addEventListener = <span class="hljs-function">(<span class="hljs-params">eventName, handler, opts</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addImpl</span>(eventName, handler, opts);

  <span class="hljs-comment">/**
   * Add a p5 event listener bound to the **current scene**. It will be auto-removed when scenes switch.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(p5:P5, evt:any)=&gt;any</span>} <span class="hljs-variable">handler</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{id?:string</span>}} [opts]
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">() =&gt; void</span>}
   */</span>
  addEventListenerScoped = <span class="hljs-function">(<span class="hljs-params">eventName, handler, opts</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addScopedImpl</span>(eventName, handler, opts);

  <span class="hljs-comment">/**
   * Remove a previously added listener by its id (only needed if you assigned an explicit id in opts).
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">id</span>
   */</span>
  removeEventListener = <span class="hljs-function">(<span class="hljs-params">eventName, id</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeImpl</span>(eventName, id);
}
</code></pre>

<h3><code>src/lib/p5/scenes/AbstractP5Scene.js</code></h3>
<p>Base class with JSDoc (works great in JS projects).</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('p5')</span>} <span class="hljs-variable">P5</span>
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('../types').SceneContext</span>} <span class="hljs-variable">SceneContext</span>
 */</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotImplementedError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TypeError</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">cls</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">methodFn</span>
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">cls, methodFn</span>) {
    <span class="hljs-keyword">const</span> method = (methodFn &amp;&amp; methodFn.<span class="hljs-property">name</span>) || <span class="hljs-string">"&lt;anonymous&gt;"</span>;
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">`Abstract method <span class="hljs-subst">${cls.name}</span>.<span class="hljs-subst">${method}</span>() is not implemented`</span>);
  }
}

<span class="hljs-comment">/**
 * Base class for scenes. Extend and implement lifecycle methods.
 * <span class="hljs-doctag">@abstract</span>
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractP5Scene</span> {
  <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">string|null</span>} Unique key for this scene (may be overridden by &lt;P5.Scene name=...&gt;) */</span>
  <span class="hljs-keyword">static</span> scene = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">_p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">_ctx</span>
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">_p5, _ctx</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">AbstractP5Scene</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Cannot instantiate AbstractP5Scene directly."</span>);
    }
    <span class="hljs-keyword">const</span> s = <span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">*</span>} */</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>).<span class="hljs-property">scene</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s !== <span class="hljs-string">"string"</span> || !s.<span class="hljs-title function_">trim</span>()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`Static 'scene' must be a non-empty string on <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.constructor.name}</span>`</span>);
    }
  }

  <span class="hljs-comment">/**
   * Preload heavy assets (images, fonts, shaders, etc).
   * Called when `ctx.preload(name)` is invoked or before first activate when possible.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void|Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-title function_">preload</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">preload</span>); }

  <span class="hljs-comment">/**
   * One-time setup right before the first draw of this scene.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
   */</span>
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">setup</span>); }

  <span class="hljs-comment">/**
   * Draw loop (called each frame).
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
   */</span>
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5, ctx</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotImplementedError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">draw</span>); }

  <span class="hljs-comment">/**
   * Optional cleanup when leaving the scene (free textures, detach listeners, etc).
   * Executed asynchronously; you may await tasks if needed.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">P5</span>} <span class="hljs-variable">_p5</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SceneContext</span>} <span class="hljs-variable">_ctx</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void|Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">_p5, _ctx</span>) { <span class="hljs-comment">/* optional */</span> }
}
</code></pre>

<h3><code>src/lib/p5/context/CanvasContext.jsx</code></h3>
<p>Internal context for <code>&lt;P5.Canvas&gt;</code> children (e.g., <code>&lt;P5.Scene&gt;</code>). Components use this; scenes receive <code>SceneContext</code> at runtime.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">/**
 * CanvasContext is used by components rendered as children of &lt;P5.Canvas&gt;,
 * such as &lt;P5.Scene&gt;, to register themselves and to access Canvas wiring.
 * Scene classes DO NOT consume this; they get a SceneContext instance instead.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CanvasContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);
</code></pre>

<h3><code>src/lib/p5/context/RegistryContext.jsx</code></h3>
<p>A simple in-memory registry used by <code>useP5(id)</code> and updated by <code>&lt;P5.Canvas&gt;</code>.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { createContext, useCallback, useMemo, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">/**
 * Shape per canvas:
 * {
 *   p5Ref, canvasRef,
 *   ready: boolean,
 *   size: {width, height},
 *   setScene, preload, addEventListener, addEventListenerScoped, removeEventListener
 * }
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">RegistryContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ContextProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [version, setVersion] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> mapRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());

  <span class="hljs-keyword">const</span> registerCanvas = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">id, entry</span>) =&gt;</span> {
    mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(id, { ...(mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(id) || {}), ...entry });
    <span class="hljs-title function_">setVersion</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v + <span class="hljs-number">1</span>);
  }, []);

  <span class="hljs-keyword">const</span> unregisterCanvas = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {
    mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(id);
    <span class="hljs-title function_">setVersion</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v + <span class="hljs-number">1</span>);
  }, []);

  <span class="hljs-keyword">const</span> updateCanvas = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">id, patch</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> prev = mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(id);
    <span class="hljs-keyword">if</span> (!prev) <span class="hljs-keyword">return</span>;
    mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(id, { ...prev, ...patch });
    <span class="hljs-title function_">setVersion</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v + <span class="hljs-number">1</span>);
  }, []);

  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(
    <span class="hljs-function">() =&gt;</span> ({
      registerCanvas,
      unregisterCanvas,
      updateCanvas,
      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(id),
      <span class="hljs-attr">list</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">keys</span>()),
      version, <span class="hljs-comment">// allow subscribers to react to changes</span>
    }),
    [registerCanvas, unregisterCanvas, updateCanvas, version]
  );

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RegistryContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">RegistryContext.Provider</span>&gt;</span></span>;
}
</code></pre>

<h3><code>src/lib/p5/components/P5Scene.jsx</code></h3>
<p>Declarative scene registration. No rendering; just tells the canvas the scene class for <code>name</code>.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useContext, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;

<span class="hljs-comment">/**
 * &lt;P5.Scene name cls&gt;
 * Registers a scene class under a given name (or cls.scene).
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Scene</span>(<span class="hljs-params">{ name, cls }</span>) {
  <span class="hljs-keyword">const</span> ctx = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CanvasContext</span>);
  <span class="hljs-keyword">if</span> (!ctx) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Scene&gt; must be used inside &lt;P5.Canvas&gt;."</span>);

  <span class="hljs-keyword">const</span> sceneName = name || (cls &amp;&amp; cls.<span class="hljs-property">scene</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    ctx.<span class="hljs-title function_">registerScene</span>(sceneName, cls);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> ctx.<span class="hljs-title function_">unregisterScene</span>(sceneName);
  }, [ctx, sceneName, cls]);

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>

<h3><code>src/lib/p5/components/P5Canvas.jsx</code></h3>
<p>The heart: p5 instance lifecycle, scene registry/manager, multi-listener events, scoped listeners.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Children</span>,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;
<span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"../p5"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SceneContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types"</span>;

<span class="hljs-comment">/**
 * &lt;P5.Canvas id width height renderer className style scene&gt;
 * Children should be &lt;P5.Scene&gt; elements.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Canvas</span>(<span class="hljs-params">{
  id,
  width,
  height,
  renderer = <span class="hljs-string">"P2D"</span>,
  className,
  style,
  scene, // optional initial scene name; <span class="hljs-keyword">if</span> not set, first &lt;P5.Scene&gt; becomes active
  children,
}</span>) {
  <span class="hljs-keyword">if</span> (!id) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; requires an 'id' prop."</span>);

  <span class="hljs-comment">// DOM host for p5 instance</span>
  <span class="hljs-keyword">const</span> hostDivRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// p5 instance + canvas</span>
  <span class="hljs-keyword">const</span> p5Ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> canvasRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// boot + recreate</span>
  <span class="hljs-keyword">const</span> [bootReady, setBootReady] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [instanceKey, setInstanceKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> hasInstanceRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-comment">// listeners: Map&lt;eventName, Map&lt;listenerId, fn&gt;&gt;</span>
  <span class="hljs-keyword">const</span> listenersRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  <span class="hljs-keyword">const</span> sceneSubscriptionsRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()); <span class="hljs-comment">// Set&lt;() =&gt; void&gt; auto-removed on scene switch</span>

  <span class="hljs-comment">// scenes: Map&lt;name, { cls, instance?, status?:'idle'|'preloaded'|'setup' }&gt;</span>
  <span class="hljs-keyword">const</span> scenesRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  <span class="hljs-keyword">const</span> preloadPromisesRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  <span class="hljs-keyword">const</span> currentSceneRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> { registerCanvas, updateCanvas, unregisterCanvas } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>) || {};
  <span class="hljs-keyword">if</span> (!registerCanvas) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; must be used inside &lt;P5.ContextProvider&gt;."</span>);

  <span class="hljs-comment">// ---- utilities</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">makeId</span> = (<span class="hljs-params"></span>) =&gt;
    (<span class="hljs-keyword">typeof</span> crypto !== <span class="hljs-string">"undefined"</span> &amp;&amp; crypto.<span class="hljs-property">randomUUID</span>)
      ? crypto.<span class="hljs-title function_">randomUUID</span>()
      : <span class="hljs-string">`l_<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).slice(<span class="hljs-number">2</span>)}</span>`</span>;

  <span class="hljs-keyword">const</span> addEventListener = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, fn, opts = {}</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!eventName || <span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {};
    <span class="hljs-keyword">let</span> m = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
    <span class="hljs-keyword">if</span> (!m) {
      m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
      listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(eventName, m);
    }
    <span class="hljs-keyword">const</span> id = opts.<span class="hljs-property">id</span> || <span class="hljs-title function_">makeId</span>();
    m.<span class="hljs-title function_">set</span>(id, fn);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> mm = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
      <span class="hljs-keyword">if</span> (!mm) <span class="hljs-keyword">return</span>;
      mm.<span class="hljs-title function_">delete</span>(id);
      <span class="hljs-keyword">if</span> (mm.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(eventName);
    };
  }, []);

  <span class="hljs-keyword">const</span> removeEventListener = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, id</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> m = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
    <span class="hljs-keyword">if</span> (!m) <span class="hljs-keyword">return</span>;
    m.<span class="hljs-title function_">delete</span>(id);
    <span class="hljs-keyword">if</span> (m.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(eventName);
  }, []);

  <span class="hljs-keyword">const</span> addEventListenerScoped = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, fn, opts = {}</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> unsub = <span class="hljs-title function_">addEventListener</span>(eventName, fn, opts);
    sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">add</span>(unsub);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">try</span> { <span class="hljs-title function_">unsub</span>(); } <span class="hljs-keyword">finally</span> { sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(unsub); }
    };
  }, [addEventListener]);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearSceneSubscriptions</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> unsub <span class="hljs-keyword">of</span> sceneSubscriptionsRef.<span class="hljs-property">current</span>) {
      <span class="hljs-keyword">try</span> { <span class="hljs-title function_">unsub</span>(); } <span class="hljs-keyword">catch</span> {}
    }
    sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">clear</span>();
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params">eventName, arg</span>) =&gt; {
    <span class="hljs-keyword">const</span> m = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
    <span class="hljs-keyword">if</span> (!m || m.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">let</span> anyTruthy = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">values</span>()) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">fn</span>(p5Ref.<span class="hljs-property">current</span>, arg);
        <span class="hljs-keyword">if</span> (res) anyTruthy = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] listener error for <span class="hljs-subst">${eventName}</span>`</span>, e);
      }
    }
    <span class="hljs-keyword">return</span> anyTruthy;
  };

  <span class="hljs-comment">// ---- scene management</span>

  <span class="hljs-keyword">const</span> registerScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">name, cls</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!name || !cls) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(name)) {
      scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(name, { cls, <span class="hljs-attr">status</span>: <span class="hljs-string">"idle"</span>, <span class="hljs-attr">instance</span>: <span class="hljs-literal">null</span> });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
      rec.<span class="hljs-property">cls</span> = cls;
    }
  }, []);

  <span class="hljs-keyword">const</span> unregisterScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
    scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(name);
    <span class="hljs-keyword">if</span> (currentSceneRef.<span class="hljs-property">current</span> === name) {
      <span class="hljs-comment">// leave selection to caller; optionally auto-switch here</span>
    }
  }, []);

  <span class="hljs-keyword">const</span> makeSceneContext = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SceneContext</span>({
      id,
      <span class="hljs-attr">preload</span>: <span class="hljs-title function_">async</span> (name) =&gt; <span class="hljs-keyword">await</span> <span class="hljs-title function_">preloadScene</span>(name),
      <span class="hljs-attr">setScene</span>: <span class="hljs-title function_">async</span> (name) =&gt; <span class="hljs-keyword">await</span> <span class="hljs-title function_">setScene</span>(name),
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
    });
  }, [id, addEventListener, addEventListenerScoped, removeEventListener]);

  <span class="hljs-keyword">const</span> preloadScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> (name) =&gt; {
    <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
    <span class="hljs-keyword">if</span> (!rec) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(name)) <span class="hljs-keyword">return</span> preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">const</span> p5 = p5Ref.<span class="hljs-property">current</span>;
      <span class="hljs-keyword">if</span> (!p5) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// can be called pre-instance; we'll preload on activate</span>
      <span class="hljs-keyword">if</span> (!rec.<span class="hljs-property">instance</span>) rec.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> rec.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
      <span class="hljs-keyword">if</span> (rec.<span class="hljs-property">instance</span>.<span class="hljs-property">preload</span>) <span class="hljs-keyword">await</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">preload</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
      rec.<span class="hljs-property">status</span> = <span class="hljs-string">"preloaded"</span>;
    };

    <span class="hljs-keyword">const</span> prom = <span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e); rec.<span class="hljs-property">status</span> = <span class="hljs-string">"idle"</span>; });
    preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(name, prom);
    <span class="hljs-keyword">return</span> prom;
  }, [makeSceneContext]);

  <span class="hljs-keyword">const</span> setScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-title function_">async</span> (name) =&gt; {
    <span class="hljs-keyword">if</span> (!name || currentSceneRef.<span class="hljs-property">current</span> === name) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> p5 = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> next = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
    <span class="hljs-keyword">if</span> (!next) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> prevName = currentSceneRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">const</span> prev = prevName ? scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(prevName) : <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// destroy previous (async, best-effort)</span>
    <span class="hljs-keyword">if</span> (prev &amp;&amp; prev.<span class="hljs-property">instance</span> &amp;&amp; <span class="hljs-keyword">typeof</span> prev.<span class="hljs-property">instance</span>.<span class="hljs-property">destroy</span> === <span class="hljs-string">"function"</span>) {
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(prev.<span class="hljs-property">instance</span>.<span class="hljs-title function_">destroy</span>(p5, <span class="hljs-title function_">makeSceneContext</span>())).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
    }
    <span class="hljs-title function_">clearSceneSubscriptions</span>();

    <span class="hljs-comment">// preload if p5 exists now; if not, we'll do it at activate time</span>
    <span class="hljs-keyword">if</span> (p5) <span class="hljs-keyword">await</span> <span class="hljs-title function_">preloadScene</span>(name);

    <span class="hljs-comment">// ensure instance + setup</span>
    <span class="hljs-keyword">if</span> (p5) {
      <span class="hljs-keyword">if</span> (!next.<span class="hljs-property">instance</span>) next.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> next.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
      <span class="hljs-keyword">if</span> (next.<span class="hljs-property">status</span> !== <span class="hljs-string">"setup"</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> next.<span class="hljs-property">instance</span>.<span class="hljs-property">setup</span> === <span class="hljs-string">"function"</span>) {
          next.<span class="hljs-property">instance</span>.<span class="hljs-title function_">setup</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
        }
        next.<span class="hljs-property">status</span> = <span class="hljs-string">"setup"</span>;
      }
    }

    currentSceneRef.<span class="hljs-property">current</span> = name;
    <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">currentScene</span>: name });
  }, [makeSceneContext, preloadScene, updateCanvas, id]);

  <span class="hljs-comment">// ---- boot barrier (let children register scenes first)</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-title function_">setBootReady</span>(<span class="hljs-literal">true</span>); }, []);

  <span class="hljs-comment">// ---- registry lifecycle</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">registerCanvas</span>(id, {
      p5Ref,
      canvasRef,
      <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">size</span>: { width, height },
      <span class="hljs-comment">// Expose public runtime methods through the registry/useP5</span>
      setScene,
      <span class="hljs-attr">preload</span>: preloadScene,
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
    });
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">unregisterCanvas</span>(id);
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [id]);

  <span class="hljs-comment">// keep size up to date in registry</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
  }, [id, width, height, updateCanvas]);

  <span class="hljs-comment">// ---- create / recreate p5 instance</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!bootReady) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> host = hostDivRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!host) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sketch</span> = (<span class="hljs-params">p5</span>) =&gt; {
      p5Ref.<span class="hljs-property">current</span> = p5;

      <span class="hljs-comment">// Bind multiplexed p5 events to dispatcher</span>
      p5.<span class="hljs-property">mouseMoved</span>     = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseMoved"</span>, e);
      p5.<span class="hljs-property">mousePressed</span>   = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mousePressed"</span>, e);
      p5.<span class="hljs-property">mouseDragged</span>   = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseDragged"</span>, e);
      p5.<span class="hljs-property">mouseReleased</span>  = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseReleased"</span>, e);
      p5.<span class="hljs-property">doubleClicked</span>  = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"doubleClicked"</span>, e);
      p5.<span class="hljs-property">mouseWheel</span>     = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseWheel"</span>, e);
      p5.<span class="hljs-property">keyPressed</span>     = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"keyPressed"</span>, e);
      p5.<span class="hljs-property">keyReleased</span>    = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"keyReleased"</span>, e);
      p5.<span class="hljs-property">keyTyped</span>       = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"keyTyped"</span>, e);
      p5.<span class="hljs-property">touchStarted</span>   = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"touchStarted"</span>, e);
      p5.<span class="hljs-property">touchMoved</span>     = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"touchMoved"</span>, e);
      p5.<span class="hljs-property">touchEnded</span>     = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"touchEnded"</span>, e);

      <span class="hljs-comment">// Optionally hook p5.preload for the very first scene if known now</span>
      <span class="hljs-keyword">const</span> initialName =
        scene ||
        (scenesRef.<span class="hljs-property">current</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">keys</span>())[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>);

      <span class="hljs-keyword">if</span> (initialName) {
        p5.<span class="hljs-property">preload</span> = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(initialName);
          <span class="hljs-keyword">if</span> (!rec) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">if</span> (!rec.<span class="hljs-property">instance</span>) rec.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> rec.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-property">preload</span> === <span class="hljs-string">"function"</span>) {
            <span class="hljs-keyword">return</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">preload</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
          }
        };
      }

      p5.<span class="hljs-property">setup</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> rendererConst = renderer === <span class="hljs-string">"WEBGL"</span> ? p5.<span class="hljs-property">WEBGL</span> : p5.<span class="hljs-property">P2D</span>;
        <span class="hljs-keyword">const</span> cnv = p5.<span class="hljs-title function_">createCanvas</span>(width, height, rendererConst);
        canvasRef.<span class="hljs-property">current</span> = cnv.<span class="hljs-property">elt</span>;

        <span class="hljs-comment">// activate initial scene</span>
        <span class="hljs-keyword">const</span> startName =
          initialName ||
          (scenesRef.<span class="hljs-property">current</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">keys</span>())[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>);

        <span class="hljs-keyword">if</span> (startName) {
          <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(startName);
          <span class="hljs-keyword">if</span> (!rec.<span class="hljs-property">instance</span>) rec.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> rec.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
          <span class="hljs-keyword">if</span> (rec.<span class="hljs-property">status</span> !== <span class="hljs-string">"setup"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-property">setup</span> === <span class="hljs-string">"function"</span>) {
            rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">setup</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
          }
          rec.<span class="hljs-property">status</span> = <span class="hljs-string">"setup"</span>;
          currentSceneRef.<span class="hljs-property">current</span> = startName;
          <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">currentScene</span>: startName, <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
        }

        <span class="hljs-comment">// Single draw delegator</span>
        p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> name = currentSceneRef.<span class="hljs-property">current</span>;
          <span class="hljs-keyword">if</span> (!name) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
          <span class="hljs-keyword">if</span> (rec &amp;&amp; rec.<span class="hljs-property">instance</span> &amp;&amp; <span class="hljs-keyword">typeof</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-property">draw</span> === <span class="hljs-string">"function"</span>) {
            rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">draw</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
          }
        };
        p5.<span class="hljs-title function_">loop</span>();

        hasInstanceRef.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>;
      };
    };

    <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">p5js</span>(sketch, host);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">try</span> { inst.<span class="hljs-title function_">remove</span>(); } <span class="hljs-keyword">catch</span> {}
      <span class="hljs-keyword">if</span> (p5Ref.<span class="hljs-property">current</span> === inst) p5Ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      canvasRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);
    };
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [bootReady, instanceKey, width, height, renderer, scene]);

  <span class="hljs-comment">// ---- resize / renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!inst) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> currentRenderer = inst.<span class="hljs-property">_renderer</span>?.<span class="hljs-property">GL</span>?.<span class="hljs-property">RENDERER</span>;
    <span class="hljs-keyword">const</span> desired = renderer === <span class="hljs-string">"WEBGL"</span> ? inst.<span class="hljs-property">WEBGL</span> : inst.<span class="hljs-property">P2D</span>;

    <span class="hljs-keyword">if</span> (currentRenderer === desired) {
      inst.<span class="hljs-title function_">resizeCanvas</span>(width, height);
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// renderer changed -&gt; recreate</span>
      <span class="hljs-keyword">if</span> (hasInstanceRef.<span class="hljs-property">current</span>) <span class="hljs-title function_">setInstanceKey</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> k + <span class="hljs-number">1</span>);
    }
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [width, height, renderer]);

  <span class="hljs-keyword">const</span> canvasCtxValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({
    id,
    registerScene,
    unregisterScene,
    <span class="hljs-comment">// These are exposed for components (like &lt;P5.Scene&gt;) and advanced use:</span>
    setScene,
    <span class="hljs-attr">preload</span>: preloadScene,
    addEventListener,
    addEventListenerScoped,
    removeEventListener,
  }), [
    id,
    registerScene,
    unregisterScene,
    setScene,
    preloadScene,
    addEventListener,
    addEventListenerScoped,
    removeEventListener,
  ]);

  <span class="hljs-comment">// Let children (e.g., &lt;P5.Scene&gt;) register themselves</span>
  <span class="hljs-keyword">const</span> renderedChildren = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">map</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CanvasContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{canvasCtxValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{hostDivRef}</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
        <span class="hljs-attr">data-testid</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">p5-host-</span>${<span class="hljs-attr">id</span>}`}
        <span class="hljs-attr">suppressHydrationWarning</span>
      /&gt;</span>
      {renderedChildren}
    <span class="hljs-tag">&lt;/<span class="hljs-name">CanvasContext.Provider</span>&gt;</span></span>
  );
}
</code></pre>

<h3><code>src/lib/p5/hooks/useP5.js</code></h3>
<p>Expose scene controls + listener helpers to app code.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useContext, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;

<span class="hljs-comment">/**
 * Access a canvas entry by id: status + controls.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP5</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">const</span> reg = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>);
  <span class="hljs-keyword">if</span> (!reg) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"useP5 must be used inside &lt;P5.ContextProvider&gt;."</span>);

  <span class="hljs-keyword">const</span> entry = reg.<span class="hljs-title function_">get</span>(id);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!entry) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> {
      p5Ref,
      canvasRef,
      size,
      <span class="hljs-comment">// scene controls</span>
      setScene,
      preload,
      <span class="hljs-comment">// events</span>
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
      <span class="hljs-comment">// ready &amp; anything else the canvas stores:</span>
      ...rest
    } = entry;

    <span class="hljs-keyword">return</span> {
      p5Ref,
      canvasRef,
      size,
      <span class="hljs-attr">ready</span>: !!entry.<span class="hljs-property">ready</span>,
      <span class="hljs-attr">currentScene</span>: entry.<span class="hljs-property">currentScene</span> || <span class="hljs-literal">null</span>,
      setScene,
      preload,
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
      ...rest,
    };
  }, [entry, reg.<span class="hljs-property">version</span>]);
}
</code></pre>

<h3><code>src/lib/p5/hooks/useP5List.js</code></h3>
<p>(unchanged; still useful)</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { useContext, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;

<span class="hljs-comment">/** Returns an array of registered canvas IDs. */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useP5List</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> reg = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>);
  <span class="hljs-keyword">if</span> (!reg) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"useP5List must be used inside &lt;P5.ContextProvider&gt;."</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> reg.<span class="hljs-title function_">list</span>(), [reg, reg.<span class="hljs-property">version</span>]);
}
</code></pre>

<h3><code>src/lib/p5/index.js</code></h3>
<p>Public surface. <strong>No Setup/Draw exports</strong> anymore.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ContextProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./context/RegistryContext"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Canvas</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/P5Canvas"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Scene</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/P5Scene"</span>;
<span class="hljs-keyword">import</span> { useP5 } <span class="hljs-keyword">from</span> <span class="hljs-string">"./hooks/useP5"</span>;
<span class="hljs-keyword">import</span> { useP5List } <span class="hljs-keyword">from</span> <span class="hljs-string">"./hooks/useP5List"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">P5</span> = {
  <span class="hljs-title class_">ContextProvider</span>,
  <span class="hljs-title class_">Canvas</span>,
  <span class="hljs-title class_">Scene</span>,
};

<span class="hljs-keyword">export</span> { useP5, useP5List };
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"./scenes/AbstractP5Scene"</span>;
</code></pre>

<h2>Example usage</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span>, useP5, <span class="hljs-title class_">AbstractP5Scene</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"scene1"</span>;
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>) {
    ctx.<span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-string">"mouseMoved"</span>, <span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> p5.<span class="hljs-title function_">cursor</span>(<span class="hljs-string">"crosshair"</span>));
  }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5</span>) {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">30</span>);
    p5.<span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>);
    p5.<span class="hljs-title function_">circle</span>(p5.<span class="hljs-property">width</span>/<span class="hljs-number">2</span>, p5.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>, <span class="hljs-number">50</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneTwo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"scene2"</span>;
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">preload</span>(<span class="hljs-params">p5</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">font</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      p5.<span class="hljs-title function_">loadFont</span>(<span class="hljs-string">"/fonts/Inter-Regular.ttf"</span>, <span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(f));
    });
  }
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">font</span>) p5.<span class="hljs-title function_">textFont</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">font</span>);
    p5.<span class="hljs-title function_">textAlign</span>(p5.<span class="hljs-property">CENTER</span>, p5.<span class="hljs-property">CENTER</span>);
  }
  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5</span>) {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);
    p5.<span class="hljs-title function_">fill</span>(<span class="hljs-number">200</span>);
    p5.<span class="hljs-title function_">text</span>(<span class="hljs-string">"Hello Scenes!"</span>, p5.<span class="hljs-property">width</span>/<span class="hljs-number">2</span>, p5.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{600}</span> <span class="hljs-attr">renderer</span>=<span class="hljs-string">"P2D"</span> <span class="hljs-attr">scene</span>=<span class="hljs-string">"scene1"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">cls</span>=<span class="hljs-string">{SceneOne}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">cls</span>=<span class="hljs-string">{SceneTwo}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>
<p>You can switch scenes anywhere (e.g., a button):</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> { setScene, preload } = <span class="hljs-title function_">useP5</span>(<span class="hljs-string">"demo"</span>);
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> preload("scene2").then(() =&gt; setScene("scene2"))}&gt;
  Go to Scene 2
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>

<p>If you want me to also add a tiny <code>useP5Event(id, event, handler)</code> hook that wraps <code>addEventListenerScoped</code>, I can include it, but the above API already gives you scene-scoped listeners and app-level control.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Are you sure about the way you bind the methods of SceneContext? Using arrow functions normally binds to the outer context <code>this</code>, and in this specific case, wouldn't it bind to the module or not find a <code>this</code>?
I was expecting more something like 

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-kotlin">export <span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneContext</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {Object} args
   * <span class="hljs-doctag">@param</span> {string} args.id
   * <span class="hljs-doctag">@param</span> {(sceneName:string)=&gt;Promise&lt;void&gt;} args.preload
   * <span class="hljs-doctag">@param</span> {(sceneName:string)=&gt;Promise&lt;void&gt;} args.setScene
   * <span class="hljs-doctag">@param</span> {(ev:string, fn:(p5:P5, evt:any)=&gt;any, opts?:{id?:string}) =&gt; () =&gt; void} args.addEventListener
   * <span class="hljs-doctag">@param</span> {(ev:string, fn:(p5:P5, evt:any)=&gt;any, opts?:{id?:string}) =&gt; () =&gt; void} args.addEventListenerScoped
   * <span class="hljs-doctag">@param</span> {(ev:string, id:string) =&gt; void} args.removeEventListener
   */</span>
  <span class="hljs-keyword">constructor</span>({
    id,
    preload,
    setScene,
    addEventListener,
    addEventListenerScoped,
    removeEventListener,
  }) {
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-keyword">this</span>._id = id;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-keyword">this</span>._preloadImpl = preload;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-keyword">this</span>._setSceneImpl = setScene;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-keyword">this</span>._addImpl = addEventListener;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-keyword">this</span>._addScopedImpl = addEventListenerScoped;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-keyword">this</span>._removeImpl = removeEventListener;

    <span class="hljs-keyword">this</span>.preload = <span class="hljs-keyword">this</span>.preload.bind(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">this</span>.setScene = <span class="hljs-keyword">this</span>.setScene.bind(<span class="hljs-keyword">this</span>)
    <span class="hljs-comment">// etc</span>
  }
  
  preload(sceneName) {
    <span class="hljs-keyword">this</span>._preloadImpl(sceneName);
  }
  
  <span class="hljs-comment">// ...other methods</span>

}</code></pre></div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Great catch—this is a subtle JS/React nuance.</p>
<p>Short answer: <strong>both patterns are valid</strong>:</p>
<ul>
<li>
<p><strong>Class fields with arrow functions</strong> (e.g., <code>preload = (name) =&gt; this._preloadImpl(name)</code>) create <strong>instance properties</strong> whose <code>this</code> is <strong>lexically bound to the instance</strong> at initialization time. There’s no “module this” involved. This works well (and is what many projects do), especially with Babel.</p>
</li>
<li>
<p><strong>Prototype methods + <code>bind</code> in the constructor</strong> (your snippet) also work and are maximally explicit/portable—especially if you ever compile without class-fields.</p>
</li>
</ul>
<p>Since you prefer the explicit bind pattern, here’s the <strong>final SceneContext</strong> using prototype methods bound in the constructor, with JSDoc and correct return types:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-comment">// src/lib/p5/types.js</span>
<span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">import('p5')</span>} <span class="hljs-variable">P5</span>
 */</span>

<span class="hljs-comment">/**
 * Public runtime API handed to scene methods.
 * Prototype methods are bound in the constructor for safe destructuring.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneContext</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">args</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} args.id
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(sceneName:string)=&gt;Promise&lt;void&gt;</span>} args.preload
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(sceneName:string)=&gt;Promise&lt;void&gt;</span>} args.setScene
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, fn:(p5:P5, evt:any)=&gt;any, opts?:{id?:string</span>}) =&gt; () =&gt; void} args.addEventListener
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, fn:(p5:P5, evt:any)=&gt;any, opts?:{id?:string</span>}) =&gt; () =&gt; void} args.addEventListenerScoped
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(ev:string, id:string) =&gt; void</span>} args.removeEventListener
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">{
    id,
    preload,
    setScene,
    addEventListener,
    addEventListenerScoped,
    removeEventListener,
  }</span>) {
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span> = id;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_preloadImpl</span> = preload;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_setSceneImpl</span> = setScene;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_addImpl</span> = addEventListener;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_addScopedImpl</span> = addEventListenerScoped;
    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_removeImpl</span> = removeEventListener;

    <span class="hljs-comment">// Bind prototype methods so destructuring remains safe</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">preload</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">preload</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setScene</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">setScene</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">addEventListener</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">addEventListener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">addEventListenerScoped</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">addEventListenerScoped</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">removeEventListener</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">removeEventListener</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
  }

  <span class="hljs-comment">/** <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} */</span>
  <span class="hljs-title function_">id</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_id</span>; }

  <span class="hljs-comment">/**
   * Eagerly preload a scene's assets by name.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sceneName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-title function_">preload</span>(<span class="hljs-params">sceneName</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_preloadImpl</span>(sceneName);
  }

  <span class="hljs-comment">/**
   * Transition to another scene by name.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sceneName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;void&gt;</span>}
   */</span>
  <span class="hljs-title function_">setScene</span>(<span class="hljs-params">sceneName</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_setSceneImpl</span>(sceneName);
  }

  <span class="hljs-comment">/**
   * Add a p5 event listener. Returns an unsubscribe function.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(p5:P5, evt:any)=&gt;any</span>} <span class="hljs-variable">handler</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{id?:string</span>}} [opts]
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">() =&gt; void</span>}
   */</span>
  <span class="hljs-title function_">addEventListener</span>(<span class="hljs-params">eventName, handler, opts</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addImpl</span>(eventName, handler, opts);
  }

  <span class="hljs-comment">/**
   * Add a p5 event listener bound to the **current scene** (auto-removed on scene switch).
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">(p5:P5, evt:any)=&gt;any</span>} <span class="hljs-variable">handler</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{id?:string</span>}} [opts]
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">() =&gt; void</span>}
   */</span>
  <span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-params">eventName, handler, opts</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_addScopedImpl</span>(eventName, handler, opts);
  }

  <span class="hljs-comment">/**
   * Remove a previously added listener by its id (only needed if you used an explicit id).
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">id</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
   */</span>
  <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-params">eventName, id</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_removeImpl</span>(eventName, id);
  }
}
</code></pre>
<h3>When are arrow-function class fields preferable?</h3>
<ul>
<li>
<p>If you’re already transpiling class fields (Babel), they’re concise and avoid manual <code>bind</code>.</p>
</li>
<li>
<p>They also slightly simplify tree-shaking of unused methods (each instance owns its own function).</p>
</li>
</ul>
<h3>When is <code>bind</code> preferable?</h3>
<ul>
<li>
<p>If you want <strong>maximum compatibility</strong> without relying on class field transforms.</p>
</li>
<li>
<p>If your team prefers explicit binding semantics.</p>
</li>
</ul>
<p>Either way, your scenes can safely do:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-js code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">const</span> { addEventListenerScoped, setScene, id } = ctx; <span class="hljs-comment">// destructure works</span>
</code></pre>
<p>and IntelliSense will still show proper types/signatures.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Fantastic, I love all of this, looks like a lot more mature lib than the previous version with P5.Draw/P5.Setup.

Notes:

<code>src/lib/p5/components/P5Canvas.jsx</code>:
- p5.preload is deprecated as of p5 2.0; please use the scene.preload function in p5.setup
- I don't see a guard that checks that Canvas's width/height arg are not undefined. Can you add some if not present?
- What happens if a different value for the scene parameter is passed to the Canvas class? Will it recreate the Canvas object? Will it cause some state to be lost?
- What happens if a method on a <code>class &lt;Name&gt; extends AbstractP5Scene</code> is not defined is called by the Canvas internals? Does it raise? Is this the preferred approach, and if yes, can you explain the rationale for it?
- I see some guards for scene methods sometimes, and sometimes not. E.g. <code>typeof prev.instance.destroy === "function"</code>; (a) Can you ensure that every required guard is in place? (b) wouldn't <code>prev.instance.destroy</code> always be of type "function" because while the instance object itself may not have a destroy method, it's parent's prototype does, and the javascript engine's mro would find it by bubbling up the inheritance chain? If so, that seems to be not an idea behaviour - I'd suggest to check prev.instance.constructor.hasOwnProperty or whatever is appropriate in JS land for checking if the specific class of an instance has a method defined

</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Love these notes — they make the library sturdier and more predictable. Below I (1) answer each question directly and (2) give you a <strong>drop-in <code>P5Canvas.jsx</code> update</strong> that implements everything you asked: remove <code>p5.preload</code>, add width/height guards, don’t recreate on <code>scene</code> prop changes, and use robust “own override” checks for scene methods.</p>

<h2>Answers to your questions</h2>
<ol>
<li>
<p><strong>p5.preload is deprecated in p5 2.0</strong></p>
<ul>
<li>
<p>✅ Agreed. In the updated implementation, I <strong>do not assign <code>p5.preload</code></strong>. Instead, I call <code>await scene.preload(p5, ctx)</code> <strong>inside <code>p5.setup</code></strong> (and also inside <code>setScene</code> when switching scenes after mount). Preloads requested <em>before</em> the instance exists are recorded and run as soon as the instance is available.</p>
</li>
</ul>
</li>
<li>
<p><strong>Guard Canvas width/height</strong></p>
<ul>
<li>
<p>✅ Added strict guards. If <code>width</code> or <code>height</code> is <code>null/undefined/NaN</code> or not finite, Canvas throws a clear error. During resize, invalid numbers are ignored (no-op) to avoid accidental recreate/resizes mid-render.</p>
</li>
</ul>
</li>
<li>
<p><strong>What happens if the <code>scene</code> prop changes</strong></p>
<ul>
<li>
<p>✅ Changing <code>scene</code> <strong>does not recreate</strong> the p5 instance. It calls <code>setScene(newName)</code> to transition gracefully:</p>
<ul>
<li>
<p>previous scene’s <code>destroy</code> (only if <strong>overridden in the concrete class</strong>; see #5)</p>
</li>
<li>
<p>eager <code>preload</code> of the next scene (awaited)</p>
</li>
<li>
<p>one-time <code>setup</code> of next scene (awaited if async)</p>
</li>
<li>
<p>update <code>currentScene</code> in the registry</p>
</li>
</ul>
</li>
<li>
<p>Assets/state on the p5 instance survive (no canvas teardown) unless the renderer changes.</p>
</li>
</ul>
</li>
<li>
<p><strong>If a scene method is not defined and is called by Canvas internals</strong></p>
<ul>
<li>
<p>In <code>AbstractP5Scene</code>, the defaults are:</p>
<ul>
<li>
<p><code>preload</code>, <code>setup</code>, <code>draw</code> → <strong>throw <code>NotImplementedError</code></strong> (so authors catch mistakes early).</p>
</li>
<li>
<p><code>destroy</code> → <strong>no-op</strong> (optional cleanup).</p>
</li>
</ul>
</li>
<li>
<p>✅ In Canvas I added <strong>friendly checks</strong> (<code>ensureImplemented</code>) before calling <code>preload/setup/draw</code>, so authors see a clear, scene-named error. This complements the base-class throws.</p>
</li>
</ul>
</li>
<li>
<p><strong>Consistent guards + detecting “real” overrides</strong></p>
<ul>
<li>
<p>✅ I added <code>isOwnOverride(instance, 'method')</code> which returns true <strong>only if the concrete subclass defines that method on its own prototype</strong> (not inherited from the abstract base). That’s used for <code>destroy</code> and other optional/behavioral checks. For required methods (<code>preload/setup/draw</code>) we still validate presence explicitly and give a helpful error.</p>
</li>
</ul>
</li>
</ol>

<h2>Drop-in: <code>src/lib/p5/components/P5Canvas.jsx</code></h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">Children</span>,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanvasContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/CanvasContext"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RegistryContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../context/RegistryContext"</span>;
<span class="hljs-keyword">import</span> p5js <span class="hljs-keyword">from</span> <span class="hljs-string">"../p5"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SceneContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AbstractP5Scene</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"../scenes/AbstractP5Scene"</span>;

<span class="hljs-comment">// ---------- small helpers</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">isFiniteNumber</span> = (<span class="hljs-params">n</span>) =&gt; <span class="hljs-keyword">typeof</span> n === <span class="hljs-string">"number"</span> &amp;&amp; <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isFinite</span>(n);

<span class="hljs-comment">/** True only if the concrete class defines the method on its own prototype (not inherited). */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isOwnOverride</span> = (<span class="hljs-params">inst, methodName</span>) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ctor</span> = inst?.<span class="hljs-property">constructor</span>;
  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Ctor</span> || !<span class="hljs-title class_">Ctor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Ctor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, methodName);
};

<span class="hljs-comment">/** Throw a crisp error if a required scene method is missing. */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ensureImplemented</span> = (<span class="hljs-params">sceneName, inst, methodName</span>) =&gt; {
  <span class="hljs-keyword">const</span> fn = inst?.[methodName];
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">`Scene "<span class="hljs-subst">${sceneName}</span>" is missing required method: <span class="hljs-subst">${methodName}</span>(). `</span> +
      <span class="hljs-string">`Did you extend AbstractP5Scene and implement <span class="hljs-subst">${methodName}</span>()?`</span>
    );
  }
};

<span class="hljs-comment">// ---------- component</span>

<span class="hljs-comment">/**
 * &lt;P5.Canvas id width height renderer className style scene&gt;
 * Children should be &lt;P5.Scene&gt; elements.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Canvas</span>(<span class="hljs-params">{
  id,
  width,
  height,
  renderer = <span class="hljs-string">"P2D"</span>,
  className,
  style,
  scene, // initial or controlled scene name
  children,
}</span>) {
  <span class="hljs-keyword">if</span> (!id) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; requires an 'id' prop."</span>);

  <span class="hljs-comment">// Validate width/height early (clear errors instead of silent misbehavior)</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isFiniteNumber</span>(width) || !<span class="hljs-title function_">isFiniteNumber</span>(height)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
      <span class="hljs-string">`&lt;P5.Canvas id="<span class="hljs-subst">${id}</span>"&gt; requires numeric width/height; got width=<span class="hljs-subst">${<span class="hljs-built_in">String</span>(
        width
      )}</span>, height=<span class="hljs-subst">${<span class="hljs-built_in">String</span>(height)}</span>`</span>
    );
  }

  <span class="hljs-comment">// DOM host for p5 instance</span>
  <span class="hljs-keyword">const</span> hostDivRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// p5 instance + canvas</span>
  <span class="hljs-keyword">const</span> p5Ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> canvasRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// boot + recreate</span>
  <span class="hljs-keyword">const</span> [bootReady, setBootReady] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [instanceKey, setInstanceKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// listeners: Map&lt;eventName, Map&lt;listenerId, fn&gt;&gt;</span>
  <span class="hljs-keyword">const</span> listenersRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  <span class="hljs-keyword">const</span> sceneSubscriptionsRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()); <span class="hljs-comment">// Set&lt;() =&gt; void&gt; auto-removed on scene switch</span>

  <span class="hljs-comment">// scenes: Map&lt;name, { cls, instance?, status?:'idle'|'preloaded'|'setup' }&gt;</span>
  <span class="hljs-keyword">const</span> scenesRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  <span class="hljs-keyword">const</span> preloadPromisesRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
  <span class="hljs-keyword">const</span> requestedPreloadsRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()); <span class="hljs-comment">// preloads requested before p5 exists</span>
  <span class="hljs-keyword">const</span> currentSceneRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> { registerCanvas, updateCanvas, unregisterCanvas } =
    <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">RegistryContext</span>) || {};
  <span class="hljs-keyword">if</span> (!registerCanvas)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"&lt;P5.Canvas&gt; must be used inside &lt;P5.ContextProvider&gt;."</span>);

  <span class="hljs-comment">// ---- utilities</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">makeId</span> = (<span class="hljs-params"></span>) =&gt;
    <span class="hljs-keyword">typeof</span> crypto !== <span class="hljs-string">"undefined"</span> &amp;&amp; crypto.<span class="hljs-property">randomUUID</span>
      ? crypto.<span class="hljs-title function_">randomUUID</span>()
      : <span class="hljs-string">`l_<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).slice(<span class="hljs-number">2</span>)}</span>`</span>;

  <span class="hljs-keyword">const</span> addEventListener = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, fn, opts = {}</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!eventName || <span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {};
    <span class="hljs-keyword">let</span> m = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
    <span class="hljs-keyword">if</span> (!m) {
      m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
      listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(eventName, m);
    }
    <span class="hljs-keyword">const</span> id = opts.<span class="hljs-property">id</span> || <span class="hljs-title function_">makeId</span>();
    m.<span class="hljs-title function_">set</span>(id, fn);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> mm = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
      <span class="hljs-keyword">if</span> (!mm) <span class="hljs-keyword">return</span>;
      mm.<span class="hljs-title function_">delete</span>(id);
      <span class="hljs-keyword">if</span> (mm.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(eventName);
    };
  }, []);

  <span class="hljs-keyword">const</span> removeEventListener = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">eventName, id</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> m = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
    <span class="hljs-keyword">if</span> (!m) <span class="hljs-keyword">return</span>;
    m.<span class="hljs-title function_">delete</span>(id);
    <span class="hljs-keyword">if</span> (m.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(eventName);
  }, []);

  <span class="hljs-keyword">const</span> addEventListenerScoped = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">eventName, fn, opts = {}</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> unsub = <span class="hljs-title function_">addEventListener</span>(eventName, fn, opts);
      sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">add</span>(unsub);
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">unsub</span>();
        } <span class="hljs-keyword">finally</span> {
          sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(unsub);
        }
      };
    },
    [addEventListener]
  );

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearSceneSubscriptions</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> unsub <span class="hljs-keyword">of</span> sceneSubscriptionsRef.<span class="hljs-property">current</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">unsub</span>();
      } <span class="hljs-keyword">catch</span> {}
    }
    sceneSubscriptionsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">clear</span>();
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params">eventName, arg</span>) =&gt; {
    <span class="hljs-keyword">const</span> m = listenersRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(eventName);
    <span class="hljs-keyword">if</span> (!m || m.<span class="hljs-property">size</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">let</span> anyTruthy = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">values</span>()) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">fn</span>(p5Ref.<span class="hljs-property">current</span>, arg);
        <span class="hljs-keyword">if</span> (res) anyTruthy = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] listener error for <span class="hljs-subst">${eventName}</span>`</span>, e);
      }
    }
    <span class="hljs-keyword">return</span> anyTruthy;
  };

  <span class="hljs-comment">// ---- scene management</span>

  <span class="hljs-keyword">const</span> registerScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">name, cls</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!name || !cls) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!(cls.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">AbstractP5Scene</span>)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(
        <span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] Scene "<span class="hljs-subst">${name}</span>" does not extend AbstractP5Scene`</span>
      );
    }
    <span class="hljs-keyword">if</span> (!scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(name)) {
      scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(name, { cls, <span class="hljs-attr">status</span>: <span class="hljs-string">"idle"</span>, <span class="hljs-attr">instance</span>: <span class="hljs-literal">null</span> });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
      rec.<span class="hljs-property">cls</span> = cls;
    }
  }, [id]);

  <span class="hljs-keyword">const</span> unregisterScene = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
    scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(name);
    <span class="hljs-keyword">if</span> (currentSceneRef.<span class="hljs-property">current</span> === name) {
      <span class="hljs-comment">// leave selection to caller; or auto-switch if you prefer</span>
    }
  }, []);

  <span class="hljs-keyword">const</span> makeSceneContext = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SceneContext</span>({
      id,
      <span class="hljs-attr">preload</span>: <span class="hljs-title function_">async</span> (name) =&gt; <span class="hljs-keyword">await</span> <span class="hljs-title function_">preloadScene</span>(name),
      <span class="hljs-attr">setScene</span>: <span class="hljs-title function_">async</span> (name) =&gt; <span class="hljs-keyword">await</span> <span class="hljs-title function_">setScene</span>(name),
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
    });
  }, [id, addEventListener, addEventListenerScoped, removeEventListener]);

  <span class="hljs-keyword">const</span> preloadScene = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-title function_">async</span> (name) =&gt; {
      <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
      <span class="hljs-keyword">if</span> (!rec) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// If no p5 yet, remember to preload at setup time</span>
      <span class="hljs-keyword">if</span> (!p5Ref.<span class="hljs-property">current</span>) {
        requestedPreloadsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">add</span>(name);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(name))
        <span class="hljs-keyword">return</span> preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);

      <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-keyword">const</span> p5 = p5Ref.<span class="hljs-property">current</span>;
        <span class="hljs-keyword">if</span> (!p5) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (!rec.<span class="hljs-property">instance</span>) rec.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> rec.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
        <span class="hljs-title function_">ensureImplemented</span>(name, rec.<span class="hljs-property">instance</span>, <span class="hljs-string">"preload"</span>);
        <span class="hljs-keyword">await</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">preload</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
        rec.<span class="hljs-property">status</span> = <span class="hljs-string">"preloaded"</span>;
      };

      <span class="hljs-keyword">const</span> prom = <span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] preload failed for "<span class="hljs-subst">${name}</span>"`</span>, e);
        rec.<span class="hljs-property">status</span> = <span class="hljs-string">"idle"</span>;
      });
      preloadPromisesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(name, prom);
      <span class="hljs-keyword">return</span> prom;
    },
    [id, makeSceneContext]
  );

  <span class="hljs-keyword">const</span> setScene = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-title function_">async</span> (name) =&gt; {
      <span class="hljs-keyword">if</span> (!name || currentSceneRef.<span class="hljs-property">current</span> === name) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">const</span> p5 = p5Ref.<span class="hljs-property">current</span>;
      <span class="hljs-keyword">const</span> next = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
      <span class="hljs-keyword">if</span> (!next) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] Unknown scene "<span class="hljs-subst">${name}</span>"`</span>);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">const</span> prevName = currentSceneRef.<span class="hljs-property">current</span>;
      <span class="hljs-keyword">const</span> prev = prevName ? scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(prevName) : <span class="hljs-literal">null</span>;

      <span class="hljs-comment">// destroy previous (only if subclass overrides destroy)</span>
      <span class="hljs-keyword">if</span> (prev?.<span class="hljs-property">instance</span> &amp;&amp; <span class="hljs-title function_">isOwnOverride</span>(prev.<span class="hljs-property">instance</span>, <span class="hljs-string">"destroy"</span>)) {
        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(prev.<span class="hljs-property">instance</span>.<span class="hljs-title function_">destroy</span>(p5, <span class="hljs-title function_">makeSceneContext</span>())).<span class="hljs-title function_">catch</span>(
          <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] destroy("<span class="hljs-subst">${prevName}</span>")`</span>, e)
        );
      }
      <span class="hljs-title function_">clearSceneSubscriptions</span>();

      <span class="hljs-comment">// preload + setup next</span>
      <span class="hljs-keyword">if</span> (p5) {
        <span class="hljs-keyword">if</span> (!next.<span class="hljs-property">instance</span>) next.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> next.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
        <span class="hljs-comment">// preload if not yet done</span>
        <span class="hljs-keyword">if</span> (next.<span class="hljs-property">status</span> !== <span class="hljs-string">"preloaded"</span> &amp;&amp; <span class="hljs-title function_">isOwnOverride</span>(next.<span class="hljs-property">instance</span>, <span class="hljs-string">"preload"</span>)) {
          <span class="hljs-keyword">await</span> <span class="hljs-title function_">preloadScene</span>(name);
        }
        <span class="hljs-comment">// setup (required)</span>
        <span class="hljs-title function_">ensureImplemented</span>(name, next.<span class="hljs-property">instance</span>, <span class="hljs-string">"setup"</span>);
        <span class="hljs-keyword">const</span> maybeSetup = next.<span class="hljs-property">instance</span>.<span class="hljs-title function_">setup</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
        <span class="hljs-keyword">if</span> (maybeSetup &amp;&amp; <span class="hljs-keyword">typeof</span> maybeSetup.<span class="hljs-property">then</span> === <span class="hljs-string">"function"</span>) {
          <span class="hljs-keyword">await</span> maybeSetup;
        }
        next.<span class="hljs-property">status</span> = <span class="hljs-string">"setup"</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// no instance yet -&gt; mark preload request</span>
        requestedPreloadsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">add</span>(name);
      }

      currentSceneRef.<span class="hljs-property">current</span> = name;
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">currentScene</span>: name });
    },
    [id, makeSceneContext, preloadScene, updateCanvas]
  );

  <span class="hljs-comment">// ---- boot barrier (let children register scenes first)</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setBootReady</span>(<span class="hljs-literal">true</span>);
  }, []);

  <span class="hljs-comment">// ---- registry lifecycle</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">registerCanvas</span>(id, {
      p5Ref,
      canvasRef,
      <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">size</span>: { width, height },
      <span class="hljs-comment">// Public runtime methods through the registry/useP5</span>
      setScene,
      <span class="hljs-attr">preload</span>: preloadScene,
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
    });
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">unregisterCanvas</span>(id);
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [id]);

  <span class="hljs-comment">// keep size up to date in registry</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
  }, [id, width, height, updateCanvas]);

  <span class="hljs-comment">// ---- create / recreate p5 instance</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!bootReady) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> host = hostDivRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!host) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sketch</span> = (<span class="hljs-params">p5</span>) =&gt; {
      p5Ref.<span class="hljs-property">current</span> = p5;

      <span class="hljs-comment">// Multiplexed events</span>
      p5.<span class="hljs-property">mouseMoved</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseMoved"</span>, e);
      p5.<span class="hljs-property">mousePressed</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mousePressed"</span>, e);
      p5.<span class="hljs-property">mouseDragged</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseDragged"</span>, e);
      p5.<span class="hljs-property">mouseReleased</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseReleased"</span>, e);
      p5.<span class="hljs-property">doubleClicked</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"doubleClicked"</span>, e);
      p5.<span class="hljs-property">mouseWheel</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"mouseWheel"</span>, e);
      p5.<span class="hljs-property">keyPressed</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"keyPressed"</span>, e);
      p5.<span class="hljs-property">keyReleased</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"keyReleased"</span>, e);
      p5.<span class="hljs-property">keyTyped</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"keyTyped"</span>, e);
      p5.<span class="hljs-property">touchStarted</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"touchStarted"</span>, e);
      p5.<span class="hljs-property">touchMoved</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"touchMoved"</span>, e);
      p5.<span class="hljs-property">touchEnded</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">"touchEnded"</span>, e);

      p5.<span class="hljs-property">setup</span> = <span class="hljs-title function_">async</span> () =&gt; {
        <span class="hljs-keyword">const</span> rendererConst = renderer === <span class="hljs-string">"WEBGL"</span> ? p5.<span class="hljs-property">WEBGL</span> : p5.<span class="hljs-property">P2D</span>;
        <span class="hljs-keyword">const</span> cnv = p5.<span class="hljs-title function_">createCanvas</span>(width, height, rendererConst);
        canvasRef.<span class="hljs-property">current</span> = cnv.<span class="hljs-property">elt</span>;

        <span class="hljs-comment">// Initial scene resolution</span>
        <span class="hljs-keyword">const</span> initialName =
          scene ||
          (scenesRef.<span class="hljs-property">current</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>
            ? <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">keys</span>())[<span class="hljs-number">0</span>]
            : <span class="hljs-literal">null</span>);

        <span class="hljs-keyword">if</span> (initialName) {
          <span class="hljs-comment">// instantiate + preload (if requested/available) + setup</span>
          <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(initialName);
          <span class="hljs-keyword">if</span> (!rec.<span class="hljs-property">instance</span>) rec.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> rec.<span class="hljs-title function_">cls</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());

          <span class="hljs-comment">// run any preloads requested before p5 existed</span>
          <span class="hljs-keyword">if</span> (
            requestedPreloadsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">has</span>(initialName) ||
            <span class="hljs-title function_">isOwnOverride</span>(rec.<span class="hljs-property">instance</span>, <span class="hljs-string">"preload"</span>)
          ) {
            <span class="hljs-comment">// If subclass has its own preload, run it. We also honor prior preload requests.</span>
            <span class="hljs-keyword">try</span> {
              <span class="hljs-title function_">ensureImplemented</span>(initialName, rec.<span class="hljs-property">instance</span>, <span class="hljs-string">"preload"</span>);
              <span class="hljs-keyword">await</span> rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">preload</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
              rec.<span class="hljs-property">status</span> = <span class="hljs-string">"preloaded"</span>;
            } <span class="hljs-keyword">catch</span> (e) {
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] preload("<span class="hljs-subst">${initialName}</span>")`</span>, e);
            } <span class="hljs-keyword">finally</span> {
              requestedPreloadsRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">delete</span>(initialName);
            }
          }

          <span class="hljs-comment">// setup (required)</span>
          <span class="hljs-keyword">try</span> {
            <span class="hljs-title function_">ensureImplemented</span>(initialName, rec.<span class="hljs-property">instance</span>, <span class="hljs-string">"setup"</span>);
            <span class="hljs-keyword">const</span> maybeSetup = rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">setup</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
            <span class="hljs-keyword">if</span> (maybeSetup &amp;&amp; <span class="hljs-keyword">typeof</span> maybeSetup.<span class="hljs-property">then</span> === <span class="hljs-string">"function"</span>) {
              <span class="hljs-keyword">await</span> maybeSetup;
            }
            rec.<span class="hljs-property">status</span> = <span class="hljs-string">"setup"</span>;
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] setup("<span class="hljs-subst">${initialName}</span>")`</span>, e);
          }

          currentSceneRef.<span class="hljs-property">current</span> = initialName;
          <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">currentScene</span>: initialName, <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">true</span> });
        }

        <span class="hljs-comment">// Single draw delegator (required)</span>
        p5.<span class="hljs-property">draw</span> = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> name = currentSceneRef.<span class="hljs-property">current</span>;
          <span class="hljs-keyword">if</span> (!name) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">const</span> rec = scenesRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(name);
          <span class="hljs-keyword">if</span> (!rec || !rec.<span class="hljs-property">instance</span>) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">try</span> {
            <span class="hljs-title function_">ensureImplemented</span>(name, rec.<span class="hljs-property">instance</span>, <span class="hljs-string">"draw"</span>);
            rec.<span class="hljs-property">instance</span>.<span class="hljs-title function_">draw</span>(p5, <span class="hljs-title function_">makeSceneContext</span>());
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-comment">// draw is required; surface error but keep loop running</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[P5.Canvas:<span class="hljs-subst">${id}</span>] draw("<span class="hljs-subst">${name}</span>")`</span>, e);
          }
        };
        p5.<span class="hljs-title function_">loop</span>();
      };
    };

    <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">p5js</span>(sketch, host);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">ready</span>: <span class="hljs-literal">false</span> });
      <span class="hljs-keyword">try</span> {
        inst.<span class="hljs-title function_">remove</span>();
      } <span class="hljs-keyword">catch</span> {}
      <span class="hljs-keyword">if</span> (p5Ref.<span class="hljs-property">current</span> === inst) p5Ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      canvasRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">while</span> (host.<span class="hljs-property">firstChild</span>) host.<span class="hljs-title function_">removeChild</span>(host.<span class="hljs-property">firstChild</span>);
    };
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [bootReady, instanceKey, width, height, renderer, scene]);

  <span class="hljs-comment">// ---- resize / renderer change</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> inst = p5Ref.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">if</span> (!inst) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> currentRenderer = inst.<span class="hljs-property">_renderer</span>?.<span class="hljs-property">GL</span>?.<span class="hljs-property">RENDERER</span>;
    <span class="hljs-keyword">const</span> desired = renderer === <span class="hljs-string">"WEBGL"</span> ? inst.<span class="hljs-property">WEBGL</span> : inst.<span class="hljs-property">P2D</span>;

    <span class="hljs-keyword">if</span> (currentRenderer === desired) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFiniteNumber</span>(width) &amp;&amp; <span class="hljs-title function_">isFiniteNumber</span>(height)) {
        inst.<span class="hljs-title function_">resizeCanvas</span>(width, height);
        <span class="hljs-title function_">updateCanvas</span>(id, { <span class="hljs-attr">size</span>: { width, height } });
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// renderer changed -&gt; recreate</span>
      <span class="hljs-title function_">setInstanceKey</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> k + <span class="hljs-number">1</span>);
    }
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, [width, height, renderer]);

  <span class="hljs-comment">// ---- respond to controlled scene prop changes (no recreate)</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!bootReady || !p5Ref.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!scene) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (scene !== currentSceneRef.<span class="hljs-property">current</span>) {
      <span class="hljs-title function_">setScene</span>(scene);
    }
  }, [scene, bootReady, setScene]);

  <span class="hljs-keyword">const</span> canvasCtxValue = <span class="hljs-title function_">useMemo</span>(
    <span class="hljs-function">() =&gt;</span> ({
      id,
      registerScene,
      unregisterScene,
      <span class="hljs-comment">// Exposed runtime controls for advanced use/components:</span>
      setScene,
      <span class="hljs-attr">preload</span>: preloadScene,
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
    }),
    [
      id,
      registerScene,
      unregisterScene,
      setScene,
      preloadScene,
      addEventListener,
      addEventListenerScoped,
      removeEventListener,
    ]
  );

  <span class="hljs-comment">// Let children (e.g., &lt;P5.Scene&gt;) register themselves</span>
  <span class="hljs-keyword">const</span> renderedChildren = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">map</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CanvasContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{canvasCtxValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{hostDivRef}</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
        <span class="hljs-attr">data-testid</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">p5-host-</span>${<span class="hljs-attr">id</span>}`}
        <span class="hljs-attr">suppressHydrationWarning</span>
      /&gt;</span>
      {renderedChildren}
    <span class="hljs-tag">&lt;/<span class="hljs-name">CanvasContext.Provider</span>&gt;</span></span>
  );
}
</code></pre>

<h3>Why this satisfies each requirement</h3>
<ul>
<li>
<p><strong>No <code>p5.preload</code></strong>: all preloading runs in <code>setup</code> time (or on scene switches) via <code>await scene.preload</code>.</p>
</li>
<li>
<p><strong>Width/height guards</strong>: clear error if missing/invalid; safe no-op during resize if numbers aren’t valid.</p>
</li>
<li>
<p><strong>Changing <code>scene</code> prop</strong>: uses <code>setScene</code> (no recreate), preserving p5 state and only running destroy/preload/setup as needed.</p>
</li>
<li>
<p><strong>Missing methods</strong>: you’ll see crisp errors via <code>ensureImplemented</code> for required ones; <code>destroy</code> only called if the subclass <strong>actually</strong> overrides it (<code>isOwnOverride</code>).</p>
</li>
<li>
<p><strong>Consistent guards</strong>: every place we call into a scene, the check is in place.</p>
</li>
</ul>
<p>If you want, I can also push the same “own override” check onto <code>preload</code> (already done) and make <code>setup/draw</code> optional by contract, but I kept them <strong>required</strong> because that gives the best developer feedback when scenes are incomplete.</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">You seem to have a circular dependency in the <code>makeSceneContext</code> and <code>preloadScene</code> useCallback. makeSceneContext is declared before <code>preloadScene</code>, and <code>setScene</code>, and doesn't declare either as deps; is this intended, and if so, will both be defined when the arrow functions using them will be called (I guess that they will infer from the this local context of declaration, which is <code>Canvas</code>, and which registers all names in the scope on the function's <code>this</code>, correct?)</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Great eye — you’re right to question that. Let me unpack what’s going on and give you a clean, cycle-free fix.</p>
<h2>What’s happening (and why it <em>usually</em> works)</h2>
<ul>
<li>
<p>In a React function component, <code>useCallback</code> closures capture variables <strong>by reference</strong>, not by value. The variables (<code>setScene</code>, <code>preloadScene</code>) are resolved when the callback <strong>runs</strong>, not when it’s <strong>declared</strong>.</p>
</li>
<li>
<p>Having <code>makeSceneContext</code> declared before <code>preloadScene</code>/<code>setScene</code> isn’t a runtime problem by itself, because we don’t call <code>makeSceneContext</code> until later (after all hooks have run for that render).</p>
</li>
<li>
<p>However, <strong>dependency arrays</strong> are compared against the <strong>previous render’s</strong> values. If you put <code>makeSceneContext</code> in <code>setScene</code>’s deps and <code>setScene</code> in <code>makeSceneContext</code>’s deps, you’ve created a <strong>mutual dependency</strong> that can cause both identities to churn more than necessary, and it’s easy to make something subtly stale or trigger avoidable effect reruns.</p>
</li>
</ul>
<h2>The robust pattern: break the cycle with refs</h2>
<p>We can eliminate the dependency “triangle” by having <code>SceneContext</code> call <strong>ref’d</strong> APIs. That way:</p>
<ul>
<li>
<p><code>makeSceneContext</code> never depends on <code>setScene</code>/<code>preloadScene</code>.</p>
</li>
<li>
<p><code>setScene</code>/<code>preloadScene</code> can use <code>makeSceneContext</code> freely.</p>
</li>
<li>
<p>The scene always invokes the <strong>latest</strong> versions via the refs.</p>
</li>
</ul>
<h3>Minimal patch to <code>P5Canvas.jsx</code></h3>
<p>Add two refs to hold the current implementations:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-addition">+ const apiRef = useRef({</span>
<span class="hljs-addition">+   setScene: /** @type {null | ((name:string)=&gt;Promise&lt;void&gt;)} */ (null),</span>
<span class="hljs-addition">+   preloadScene: /** @type {null | ((name:string)=&gt;Promise&lt;void&gt;)} */ (null),</span>
<span class="hljs-addition">+ });</span>
</code></pre>
<p>Make <code>makeSceneContext</code> read from the refs (so it doesn’t depend on those functions):</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-deletion">- const makeSceneContext = useCallback(() =&gt; {</span>
<span class="hljs-deletion">-   return new SceneContext({</span>
<span class="hljs-deletion">-     id,</span>
<span class="hljs-deletion">-     preload: async (name) =&gt; await preloadScene(name),</span>
<span class="hljs-deletion">-     setScene: async (name) =&gt; await setScene(name),</span>
<span class="hljs-deletion">-     addEventListener,</span>
<span class="hljs-deletion">-     addEventListenerScoped,</span>
<span class="hljs-deletion">-     removeEventListener,</span>
<span class="hljs-deletion">-   });</span>
<span class="hljs-deletion">- }, [id, addEventListener, addEventListenerScoped, removeEventListener]);</span>
<span class="hljs-addition">+ const makeSceneContext = useCallback(() =&gt; {</span>
<span class="hljs-addition">+   return new SceneContext({</span>
<span class="hljs-addition">+     id,</span>
<span class="hljs-addition">+     preload: async (name) =&gt; {</span>
<span class="hljs-addition">+       const fn = apiRef.current.preloadScene;</span>
<span class="hljs-addition">+       if (fn) return fn(name);</span>
<span class="hljs-addition">+     },</span>
<span class="hljs-addition">+     setScene: async (name) =&gt; {</span>
<span class="hljs-addition">+       const fn = apiRef.current.setScene;</span>
<span class="hljs-addition">+       if (fn) return fn(name);</span>
<span class="hljs-addition">+     },</span>
<span class="hljs-addition">+     addEventListener,</span>
<span class="hljs-addition">+     addEventListenerScoped,</span>
<span class="hljs-addition">+     removeEventListener,</span>
<span class="hljs-addition">+   });</span>
<span class="hljs-addition">+ }, [id, addEventListener, addEventListenerScoped, removeEventListener]);</span>
</code></pre>
<p>After you define <code>preloadScene</code> and <code>setScene</code>, keep the refs in sync:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-diff code-block hljs" style="display: block;" data-highlighted="yes"><span class="hljs-addition">+ useEffect(() =&gt; {</span>
<span class="hljs-addition">+   apiRef.current.preloadScene = preloadScene;</span>
<span class="hljs-addition">+ }, [preloadScene]);</span>
<span class="hljs-addition">+</span>
<span class="hljs-addition">+ useEffect(() =&gt; {</span>
<span class="hljs-addition">+   apiRef.current.setScene = setScene;</span>
<span class="hljs-addition">+ }, [setScene]);</span>
</code></pre>
<p>That’s it. Now there’s <strong>no circular dependency</strong> between your callbacks, no stale closures, and <code>SceneContext</code> always dispatches to the latest implementations.</p>
<h2>To your specific questions</h2>
<ul>
<li>
<p><strong>“makeSceneContext is declared before the others; will they be defined when called?”</strong>
Yes. Declarations happen during render; the callbacks <strong>run later</strong> (e.g., inside <code>p5.setup</code>, on scene switches). With the ref pattern above, we remove any ambiguity.</p>
</li>
<li>
<p><strong>“Do arrow functions bind to ‘module this’?”</strong>
Class-field arrow methods capture <code>this</code> lexically at <strong>instance</strong> creation time; there’s no “module this”. In plain functions inside a module, arrow functions capture the surrounding lexical scope (the component), not a <code>this</code>.</p>
</li>
<li>
<p><strong>“Should we include <code>preloadScene</code>/<code>setScene</code> in <code>makeSceneContext</code> deps?”</strong>
With the ref pattern, <strong>no</strong> — <code>makeSceneContext</code> depends only on stable bits. The two <code>useEffect</code> calls keep refs fresh.</p>
</li>
<li>
<p><strong>“Could we just reorder?”</strong>
You can, but <code>setScene</code> and <code>preloadScene</code> both <em>use</em> <code>makeSceneContext</code>, so you’d still have conceptual mutual references. The ref pattern is the cleanest separation.</p>
</li>
</ul>
<p>If you want, I can paste a consolidated <code>P5Canvas.jsx</code> that already includes this ref tweak along with the previous fixes (no <code>p5.preload</code>, width/height guards, own-override checks, controlled <code>scene</code> switching).</p></div>
        </div>
      
        <div class="message user-message">
          <div class="content">Fantastic, thanks for those modifications. I've integrated them myself.

Now I'd like you to take this pre-existing README:

<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-pf"><span class="hljs-comment"># React-P5 Declarative Integration</span>

This package provides a **declarative React integration <span class="hljs-keyword">for</span> p5.js**, designed as a more flexible and composable alternative <span class="hljs-keyword">to</span> [`@p5-wrapper/react`](https://github.com/p5-wrapper/react).

It enables you <span class="hljs-keyword">to</span> use `p5` sketches directly inside React applications <span class="hljs-keyword">in</span> a way that feels idiomatic: components, hooks, and context providers rather than imperative setup.

---

<span class="hljs-comment">## ✨ Key Advantages Over `@p5-wrapper/react`</span>

- **Declarative API**  
  Define `<span class="hljs-variable">&lt;P5.Setup&gt;</span>` and `<span class="hljs-variable">&lt;P5.Draw&gt;</span>` directly inside JSX. Lifecycle is tied <span class="hljs-keyword">to</span> React’s reconciliation, not imperative re-instantiation.

- **Hot-swap draw functions**  
  Replace `<span class="hljs-variable">&lt;P5.Draw fn={...} /&gt;</span>` <span class="hljs-keyword">on</span> the fly without tearing down the canvas. Enables **multi-scene** workflows and interactive transitions.

- **Multiple p5 instance support**  
  Use `<span class="hljs-variable">&lt;P5.Canvas id="..."&gt;</span>` <span class="hljs-keyword">to</span> mount multiple independent canvases. Each canvas is registered <span class="hljs-keyword">in</span> <span class="hljs-keyword">global</span> context <span class="hljs-keyword">for</span> hooks and management.

- **React <span class="hljs-keyword">state</span> &amp; interactivity**  
  Pass `params` into setup/draw functions. Combine with React <span class="hljs-keyword">state</span>, props, or context <span class="hljs-keyword">to</span> declaratively control visual <span class="hljs-keyword">state</span>. Ideal <span class="hljs-keyword">for</span> building **data models** or **state-driven scenes**.

- **Easy integration <span class="hljs-keyword">in</span> React apps**  
  Fits into existing component trees and tooling (Vite, Babel, Jest). Plays nicely with standard React patterns (hooks, context, <span class="hljs-keyword">state</span>).

- **Extends p5 with modern app features**  
  Because you are <span class="hljs-keyword">in</span> React, you can seamlessly integrate:
  - Network requests (REST, GraphQL, etc.)
  - Local caching and persistence (React Query, SWR)
  - Real-time multiplayer via WebSockets or WebRTC</code></pre>jsx
  import { P5 } from "src/lib/p5";
  import { useState, useEffect } from "react";

  function MultiplayerCanvas({ socket }) {
    const [players, setPlayers] = useState({});

    useEffect(() =&gt; {
      socket.on("players:update", (payload) =&gt; setPlayers(payload));
    }, [socket]);

    return (
      &lt;P5.Canvas id="game" width={800} height={600} renderer="WEBGL"&gt;
        &lt;P5.Setup fn={(p5) =&gt; p5.background(0)} /&gt;
        &lt;P5.Draw
          fn={(p5) =&gt; {
            p5.background(0);
            Object.values(players).forEach(({ x, y }) =&gt; {
              p5.ellipse(x, y, 20, 20);
            });
          }}
        /&gt;
      &lt;/P5.Canvas&gt;
    );
  }
  <pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-yaml"><span class="hljs-meta">---
</span>
<span class="hljs-comment">## 📦 Installation</span>

<span class="hljs-string">This</span> <span class="hljs-string">code</span> <span class="hljs-string">lives</span> <span class="hljs-string">inside</span> <span class="hljs-string">your</span> <span class="hljs-string">project</span> <span class="hljs-string">under</span> <span class="hljs-string">`src/lib/p5`.</span>
<span class="hljs-literal">No</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">step</span> <span class="hljs-string">is</span> <span class="hljs-string">required,</span> <span class="hljs-string">but</span> <span class="hljs-string">you</span> <span class="hljs-string">do</span> <span class="hljs-string">need</span> <span class="hljs-string">`p5`:</span></code></pre>bash
npm install p5
<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-yaml"><span class="hljs-meta">---
</span>
<span class="hljs-comment">## 🚀 Basic Usage</span></code></pre>jsx
import { P5 } from "src/lib/p5";

function Example() {
  return (
    &lt;P5.ContextProvider&gt;
      &lt;P5.Canvas id="demo" width={400} height={300}&gt;
        &lt;P5.Setup fn={(p5) =&gt; p5.background(200)} /&gt;
        &lt;P5.Draw
          fn={(p5) =&gt; {
            p5.background(200);
            p5.ellipse(p5.width / 2, p5.height / 2, 50, 50);
          }}
        /&gt;
      &lt;/P5.Canvas&gt;
    &lt;/P5.ContextProvider&gt;
  );
}
<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-autohotkey">### Hooks

- `useP5(id)` → access `{ ready, p5Ref, canvasRef, size }` for a specific canvas
- `useP5List()` → get an array of all registered canvas IDs

---

## ⚠️ Limitations &amp; Disadvantages

<span class="hljs-title">- **SSR caveats**:</span> p5 requires DOM APIs. This lib guards against hydration mismatches, but server-side rendering won’t render sketches. Use `typeof window !== <span class="hljs-string">"undefined"</span>` to defer if needed.
<span class="hljs-title">- **No pixel snapshots in tests**:</span> The Jest setup mocks p5. Automated tests validate lifecycle/registry logic, <span class="hljs-literal">not</span> actual rendering output.
<span class="hljs-title">- **Draw hot-swap is one-at-a-time**:</span> Only the most recent `&lt;P5.Draw&gt;` child defines `draw`. You can replace dynamically but <span class="hljs-literal">not</span> run multiple draws in parallel.
<span class="hljs-title">- **Canvas resize vs recreate**:</span> Changing `width/height` resizes, but changing renderer (`P2D` ↔ `WEBGL`) forces a full re-create.

---

## 📖 API Reference

### `&lt;P5.ContextProvider&gt;`

Global registry provider. Wrap once near the root of your app.

### `&lt;P5.Canvas id width height renderer className style&gt;`

Mount a p5 canvas.

- `id` (string) – required, unique
- `width`, `height` (number) – canvas size
- `renderer` (`"P2D<span class="hljs-string">" | "</span>WEBGL<span class="hljs-string">"`) – defaults to `"P2D"</span>`

### `&lt;P5.Setup fn params /&gt;`

One-time setup function. Changing `fn` triggers full canvas recreate.

### `&lt;P5.Draw fn params /&gt;`

Draw loop function. Changing `fn` hot-swaps without recreate.

### `useP5(id)`

<span class="hljs-title">Access registry entry for a given canvas:</span></code></pre>ts
{
  ready: boolean;
  p5Ref: Ref&lt;p5|null&gt;;
  canvasRef: Ref&lt;HTMLCanvasElement|null&gt;;
  size: { width: number, height: number };
}
<pre class="overflow-x-auto"><code data-highlighted="yes" class="hljs language-yaml"><span class="hljs-comment">### `useP5List()`</span>

<span class="hljs-string">Returns</span> <span class="hljs-string">all</span> <span class="hljs-string">registered</span> <span class="hljs-string">canvas</span> <span class="hljs-string">IDs.</span>

<span class="hljs-meta">---
</span>
<span class="hljs-comment">## 👥 Attribution</span>

<span class="hljs-bullet">-</span> <span class="hljs-string">**Primary</span> <span class="hljs-string">Architect**:</span> <span class="hljs-string">Philippe</span> <span class="hljs-string">Hébert</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">**Primary</span> <span class="hljs-string">Implementer**:</span> <span class="hljs-string">ChatGPT</span> <span class="hljs-string">(OpenAI)</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">Original design rationale and conversation logs are available in:</span>
  <span class="hljs-string">`src/lib/p5/ATTRIBUTION/*.html`,</span> <span class="hljs-string">transcribed</span> <span class="hljs-string">to</span> <span class="hljs-string">HTML</span> <span class="hljs-string">format</span> <span class="hljs-string">using</span> <span class="hljs-string">the</span> <span class="hljs-string">Firefox</span> <span class="hljs-string">Addon</span> [<span class="hljs-string">ChatGPT</span> <span class="hljs-string">Export</span>]<span class="hljs-string">(https://addons.mozilla.org/en-US/firefox/addon/chatgpt-export/)</span>

<span class="hljs-meta">---
</span>
<span class="hljs-comment">## 📄 License</span>

<span class="hljs-string">MIT</span>

<span class="hljs-string">This</span> <span class="hljs-string">code</span> <span class="hljs-string">was</span> <span class="hljs-string">written</span> <span class="hljs-string">primarily</span> <span class="hljs-string">by</span> <span class="hljs-string">ChatGPT</span> <span class="hljs-string">(OpenAI).</span> <span class="hljs-string">Works</span> <span class="hljs-string">generated</span> <span class="hljs-string">entirely</span> <span class="hljs-string">by</span> <span class="hljs-string">a</span> <span class="hljs-string">machine</span> <span class="hljs-string">without</span> <span class="hljs-string">human</span> <span class="hljs-string">creative</span> <span class="hljs-string">input</span> <span class="hljs-string">are</span> <span class="hljs-string">generally</span> <span class="hljs-string">not</span> <span class="hljs-string">copyrightable.</span>
<span class="hljs-string">That</span> <span class="hljs-string">means</span> <span class="hljs-string">there</span> <span class="hljs-string">might</span> <span class="hljs-string">be</span> <span class="hljs-literal">no</span> <span class="hljs-string">copyright</span> <span class="hljs-string">holder</span> <span class="hljs-string">at</span> <span class="hljs-string">all,</span> <span class="hljs-string">and</span> <span class="hljs-string">the</span> <span class="hljs-string">output</span> <span class="hljs-string">may</span> <span class="hljs-string">effectively</span> <span class="hljs-string">be</span> <span class="hljs-string">in</span> <span class="hljs-string">the</span> <span class="hljs-string">public</span> <span class="hljs-string">domain.</span>

<span class="hljs-string">This</span> <span class="hljs-string">being</span> <span class="hljs-string">said,</span> <span class="hljs-string">I,</span> <span class="hljs-string">as</span> <span class="hljs-string">the</span> <span class="hljs-string">author,</span> <span class="hljs-string">Philippe</span> <span class="hljs-string">Hebert,</span> <span class="hljs-string">have</span> <span class="hljs-string">made</span> <span class="hljs-string">some</span> <span class="hljs-string">creative</span> <span class="hljs-string">choices,</span> <span class="hljs-string">especially</span> <span class="hljs-string">around</span> <span class="hljs-string">architecting/directing</span>
<span class="hljs-string">the</span> <span class="hljs-string">structure</span> <span class="hljs-string">of</span> <span class="hljs-string">this</span> <span class="hljs-string">solution,</span> <span class="hljs-string">and</span> <span class="hljs-string">as</span> <span class="hljs-string">such,</span> <span class="hljs-string">I</span> <span class="hljs-string">am</span> <span class="hljs-string">de-facto</span> <span class="hljs-string">the</span> <span class="hljs-string">"author"</span> <span class="hljs-string">of</span> <span class="hljs-string">this</span> <span class="hljs-string">work.</span>
<span class="hljs-string">This</span> <span class="hljs-string">being</span> <span class="hljs-string">said,</span> <span class="hljs-string">given</span> <span class="hljs-string">that</span> <span class="hljs-string">ChatGPT</span> <span class="hljs-string">is</span> <span class="hljs-string">trained</span> <span class="hljs-string">using</span> <span class="hljs-string">the</span> <span class="hljs-string">work</span> <span class="hljs-string">of</span> <span class="hljs-string">countless</span> <span class="hljs-string">developers,</span> <span class="hljs-string">most</span> <span class="hljs-string">of</span> <span class="hljs-string">then</span> <span class="hljs-string">time</span> <span class="hljs-string">irrespectively</span> <span class="hljs-string">of</span> <span class="hljs-string">licensing,</span> <span class="hljs-string">I</span> <span class="hljs-string">also</span> <span class="hljs-string">included</span> <span class="hljs-string">"The Internet Collective"</span> <span class="hljs-string">as</span> <span class="hljs-string">a</span> <span class="hljs-string">noteworthy,</span> <span class="hljs-string">but</span> <span class="hljs-string">non-enforceable</span> <span class="hljs-string">copyright</span> <span class="hljs-string">holder.</span>

<span class="hljs-string">Full</span> <span class="hljs-string">license</span> <span class="hljs-string">is</span> <span class="hljs-string">available</span> <span class="hljs-string">in</span> <span class="hljs-string">LICENSE.md.</span></code></pre>

And modify it to reflect the changes in API + usage. Please provide a new demo example app.

You can provide a full or partial README, just make sure to keep Attribution and License sections</div>
        </div>
      
        <div class="message assistant-message">
          <div class="content"><p>Here’s an updated <strong>README.md</strong> tailored to your new <strong>Scene-based API</strong>. I’ve kept your original structure but modernized it to match the refactor.</p>

<h1>React-P5 Declarative Integration</h1>
<p>This package provides a <strong>declarative React integration for p5.js</strong>, designed as a more flexible and composable alternative to <code>@p5-wrapper/react</code>.</p>
<p>It enables you to use <code>p5</code> sketches directly inside React applications in a way that feels idiomatic: components, hooks, and context providers rather than imperative setup.</p>

<h2>✨ Key Advantages Over <code>@p5-wrapper/react</code></h2>
<ul>
<li>
<p><strong>Declarative API</strong>
Define <code>&lt;P5.Scene&gt;</code> components with ES6 classes extending <code>AbstractP5Scene</code>. Lifecycle hooks (<code>preload</code>, <code>setup</code>, <code>draw</code>, <code>destroy</code>) map cleanly to p5 phases.</p>
</li>
<li>
<p><strong>Scene support &amp; hot-swapping</strong>
Register multiple <code>&lt;P5.Scene&gt;</code> children and switch between them with <code>ctx.setScene(name)</code>. Scenes encapsulate their own event handlers, resources, and teardown.</p>
</li>
<li>
<p><strong>Multiple p5 instance support</strong>
Use <code>&lt;P5.Canvas id="..."&gt;</code> to mount multiple independent canvases. Each canvas is registered in a global registry for hooks and state management.</p>
</li>
<li>
<p><strong>Event listener management</strong>
Register multiple cursor/key/mouse event callbacks per scene with <code>ctx.addEventListener</code>. Scoped listeners are automatically removed on scene switch.</p>
</li>
<li>
<p><strong>React state &amp; interactivity</strong>
Scenes can react to external React state and props. Build declarative data-driven sketches that integrate tightly with your app.</p>
</li>
<li>
<p><strong>Easy integration in React apps</strong>
Fits into existing component trees and tooling (Vite, Babel, Jest). Plays nicely with standard React patterns (hooks, context, state).</p>
</li>
<li>
<p><strong>Extends p5 with modern app features</strong>
Because you are in React, you can seamlessly integrate:</p>
<ul>
<li>
<p>Network requests (REST, GraphQL, etc.)</p>
</li>
<li>
<p>Local caching and persistence (React Query, SWR)</p>
</li>
<li>
<p>Real-time multiplayer via WebSockets or WebRTC</p>
</li>
</ul>
</li>
</ul>

<h2>📦 Installation</h2>
<p>This code lives inside your project under <code>src/lib/p5</code>.
No npm install step is required, but you do need <code>p5</code>:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-bash code-block hljs" style="display: block;" data-highlighted="yes">npm install p5
</code></pre>
<p>Optional plugins (e.g. <code>p5.collide2d</code>) can be registered by importing them once after ensuring <code>window.p5</code> is set.</p>

<h2>🚀 Basic Usage</h2>
<pre class="overflow-visible!"><code class="whitespace-pre! language-jsx code-block hljs language-javascript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">P5</span>, <span class="hljs-title class_">AbstractP5Scene</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"src/lib/p5"</span>;

<span class="hljs-comment">// Define a scene by subclassing AbstractP5Scene</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BouncingBallScene</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"bouncing"</span>;

  <span class="hljs-title function_">setup</span>(<span class="hljs-params">p5, ctx</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = p5.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = p5.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vx</span> = <span class="hljs-number">2</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vy</span> = <span class="hljs-number">3</span>;
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">200</span>);

    <span class="hljs-comment">// Register event listener</span>
    ctx.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mousePressed"</span>, <span class="hljs-function">(<span class="hljs-params">p5</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">vx</span> *= -<span class="hljs-number">1</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">vy</span> *= -<span class="hljs-number">1</span>;
    });
  }

  <span class="hljs-title function_">draw</span>(<span class="hljs-params">p5</span>) {
    p5.<span class="hljs-title function_">background</span>(<span class="hljs-number">200</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">vx</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">vy</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> &gt; p5.<span class="hljs-property">width</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">vx</span> *= -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> &gt; p5.<span class="hljs-property">height</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">vy</span> *= -<span class="hljs-number">1</span>;
    p5.<span class="hljs-title function_">ellipse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">P5.ContextProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">P5.Canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{400}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span> <span class="hljs-attr">scene</span>=<span class="hljs-string">"bouncing"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">P5.Scene</span> <span class="hljs-attr">cls</span>=<span class="hljs-string">{BouncingBallScene}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">P5.Canvas</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">P5.ContextProvider</span>&gt;</span></span>
  );
}
</code></pre>

<h2>🎮 Scene API</h2>
<p>All scenes must extend <code>AbstractP5Scene</code> and define a static <code>scene</code> string.</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-ts code-block hljs language-typescript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScene</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractP5Scene</span> {
  <span class="hljs-keyword">static</span> scene = <span class="hljs-string">"uniqueName"</span>;

  <span class="hljs-title function_">preload</span>(<span class="hljs-attr">p5</span>: <span class="hljs-variable constant_">P5</span>, <span class="hljs-attr">ctx</span>: <span class="hljs-title class_">SceneContext</span>): <span class="hljs-built_in">void</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  <span class="hljs-title function_">setup</span>(<span class="hljs-attr">p5</span>: <span class="hljs-variable constant_">P5</span>, <span class="hljs-attr">ctx</span>: <span class="hljs-title class_">SceneContext</span>): <span class="hljs-built_in">void</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  <span class="hljs-title function_">draw</span>(<span class="hljs-attr">p5</span>: <span class="hljs-variable constant_">P5</span>, <span class="hljs-attr">ctx</span>: <span class="hljs-title class_">SceneContext</span>): <span class="hljs-built_in">void</span>;
  <span class="hljs-title function_">destroy</span>(<span class="hljs-attr">p5</span>: <span class="hljs-variable constant_">P5</span>, <span class="hljs-attr">ctx</span>: <span class="hljs-title class_">SceneContext</span>): <span class="hljs-built_in">void</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
}
</code></pre>
<ul>
<li>
<p><code>preload</code> → load assets before first render (executed inside <code>setup</code> because <code>p5.preload</code> is deprecated in p5 2.0).</p>
</li>
<li>
<p><code>setup</code> → run once when the scene becomes active.</p>
</li>
<li>
<p><code>draw</code> → runs every frame.</p>
</li>
<li>
<p><code>destroy</code> → cleanup resources, unsubscribe events.</p>
</li>
</ul>

<h2>🎛 Context API</h2>
<p>The second argument to scene methods is a <code>SceneContext</code> instance, exposing:</p>
<pre class="overflow-visible!"><code class="whitespace-pre! language-ts code-block hljs language-typescript" style="display: block;" data-highlighted="yes"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneContext</span> {
  <span class="hljs-title function_">preload</span>(<span class="hljs-attr">sceneName</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  <span class="hljs-title function_">setScene</span>(<span class="hljs-attr">sceneName</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  <span class="hljs-title function_">addEventListener</span>(<span class="hljs-attr">event</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">p5, evt</span>) =&gt;</span> <span class="hljs-built_in">any</span>, opts?: { id?: <span class="hljs-built_in">string</span> }): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-title function_">addEventListenerScoped</span>(<span class="hljs-attr">event</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params">p5, evt</span>) =&gt;</span> <span class="hljs-built_in">any</span>, opts?: { id?: <span class="hljs-built_in">string</span> }): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-attr">event</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;
}
</code></pre>
<ul>
<li>
<p><code>addEventListener</code> → subscribe to global p5 events.</p>
</li>
<li>
<p><code>addEventListenerScoped</code> → subscribe, but automatically unsubscribed when the scene is destroyed.</p>
</li>
<li>
<p><code>removeEventListener</code> → manually remove by event + id.</p>
</li>
</ul>

<h2>⚠️ Limitations &amp; Disadvantages</h2>
<ul>
<li>
<p><strong>SSR caveats</strong>: p5 requires DOM APIs. This lib guards against hydration mismatches, but server-side rendering won’t render sketches. Use <code>typeof window !== "undefined"</code> to defer if needed.</p>
</li>
<li>
<p><strong>No pixel snapshots in tests</strong>: The Jest setup mocks p5. Automated tests validate lifecycle/registry logic, not actual rendering output.</p>
</li>
<li>
<p><strong>Scene switching clears state</strong>: When switching scenes, local variables in the scene instance are discarded unless you persist them externally.</p>
</li>
<li>
<p><strong>Renderer changes recreate canvas</strong>: Switching between <code>P2D</code> and <code>WEBGL</code> forces a full recreate.</p>
</li>
</ul>

<h2>👥 Attribution</h2>
<ul>
<li>
<p><strong>Primary Architect</strong>: Philippe Hébert</p>
</li>
<li>
<p><strong>Primary Implementer</strong>: ChatGPT (OpenAI)</p>
</li>
<li>
<p>Original design rationale and conversation logs are available in:
<code>src/lib/p5/ATTRIBUTION/*.html</code>, transcribed to HTML format using the Firefox Addon ChatGPT Export</p>
</li>
</ul>

<h2>📄 License</h2>
<p>MIT</p>
<p>This code was written primarily by ChatGPT (OpenAI). Works generated entirely by a machine without human creative input are generally not copyrightable.
That means there might be no copyright holder at all, and the output may effectively be in the public domain.</p>
<p>This being said, I, as the author, Philippe Hébert, have made some creative choices, especially around architecting/directing the structure of this solution, and as such, I am de-facto the "author" of this work.
This being said, given that ChatGPT is trained using the work of countless developers, most of then time irrespectively of licensing, I also included "The Internet Collective" as a noteworthy, but non-enforceable copyright holder.</p>
<p>Full license is available in LICENSE.md.</p>

<p>Would you like me to also provide an <strong>advanced multi-scene demo</strong> (two scenes that transition with a button in React) so the README feels more complete?</p></div>
        </div>
      
          </div>
        </body>
      </html>
    